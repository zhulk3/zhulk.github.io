<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>诗词</title>
      <link href="/2022/10/14/%E8%AF%97%E8%AF%8D/"/>
      <url>/2022/10/14/%E8%AF%97%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p align="center"><strong>落日照大旗，马鸣风萧萧。<strong/></p><p align="right"><em>杜甫，后出塞五首（其二）</em></p><p align="center"><strong>细雨鱼儿出，微风燕子斜。<strong/></p><p align="right"><em>杜甫《水槛遣心二首》</em></p><p align="center"><strong>一点浩然气，千里快哉风。<strong/></p><p align="right"><em>苏轼《水调歌头·黄州快哉亭赠张偓佺》</em></p><p align="center"><strong>细雨湿流光，芳草年年与恨长。<strong/></p><p align="right"><em>冯延巳《南乡子·细雨湿流光》</em></p><p align="center"><strong>沙上并禽池上瞑，云破月来花弄影。<strong/></p><p align="right"><em>张先《天仙子·水调数声持酒听》</em></p><p align="center"><strong>可堪孤馆闭春寒，杜鹃声里斜阳暮。<strong/></p><p align="right"><em>秦观《踏莎行·郴州旅舍》</em></p><p align="center"><strong>昨夜西风凋碧树。独上高楼，望尽天涯路。<strong/></p><p align="right"><em>晏殊《蝶恋花·槛菊愁烟兰泣露》</em></p><p align="center"><strong>寒波澹澹起，白鸟悠悠下。怀归人自急，物态本闲暇。<strong/></p><p align="right"><em>元好问《颍亭留别》</em></p><p align="center"><strong>自在飞花轻似梦，无边丝雨细如愁，宝帘闲挂小银钩。<strong/></p><p align="right"><em>秦观《浣溪沙·漠漠轻寒上小楼》</em></p><p align="center"><strong>浮生长恨欢娱少，肯爱千金轻一笑。为君持酒劝斜阳，且向花间留晚照。<strong/></p><p align="right"><em>宋祁《玉楼春》</em></p>]]></content>
      
      
      <categories>
          
          <category> 阅读记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 诗词 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android架构学习</title>
      <link href="/2022/07/03/Android%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/07/03/Android%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" />]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>fail-fast and fail-safe</title>
      <link href="/2022/03/24/fail-fast%20and%20fail-safe/"/>
      <url>/2022/03/24/fail-fast%20and%20fail-safe/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Fail-fast-And-fail-safe"><a href="#Fail-fast-And-fail-safe" class="headerlink" title="Fail-fast And fail-safe"></a>Fail-fast And fail-safe</h1><p>我们可以通过迭代器遍历集合对象，迭代器分为fail-fast和fail-safe两种类型，fail-fast是指当我们通过迭代器遍历集合时，如果集合元素发生了修改，会抛出ConcurrentModificationException异常。fail-safe类迭代器则不会抛出这类异常。</p><h2 id="Fail-fast-case"><a href="#Fail-fast-case" class="headerlink" title="Fail-fast case"></a>Fail-fast case</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt;data = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    data.add(<span class="number">1</span>);</span><br><span class="line">    data.add(<span class="number">2</span>);</span><br><span class="line">    data.add(<span class="number">3</span>);</span><br><span class="line">    Iterator&lt;Integer&gt; ptr = data.iterator();</span><br><span class="line">    <span class="keyword">while</span> (ptr.hasNext())&#123;</span><br><span class="line">        Integer a = ptr.next();</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        data.remove(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行如上代码，在通过迭代器遍历集合时，对集合进行修改，删除了一个元素，迭代器在遍历时会抛出如下ConcurrentModificationException异常：</p><p><img src="https://images.zhulk3.xyz/tech/3241.png" alt="结果"></p><h2 id="Fail-Fast-Iterators-internal-working"><a href="#Fail-Fast-Iterators-internal-working" class="headerlink" title="Fail-Fast Iterators internal working"></a>Fail-Fast Iterators internal working</h2><p>以ArrayList为例，分析fail-fast的原理。ArrayList有一个迭代器内部类 ListItr, 我们在通过iterator()方法返回ArrayList对象的迭代器时就是返回这个类的一个实例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">    return new Itr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部类 ListItr 有一个属性expectedModCount，在创建 ListItr 实例时会赋值为modCount，而modCount则是在构建迭代器之前当前ArrayList实例的修改次数，当对ArrayList对象进行修改时，modCount的值都会加1。内部类 ListItr 有一个内部方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">final void checkForComodification() &#123;</span><br><span class="line">    if (modCount != expectedModCount)</span><br><span class="line">        throw new ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在通过迭代器调用next, add, remove, set等方法时，首先会执行如上checkForComodification方法，如果在这之前集合对象发生了修改，那modCount的值增加以后，将会执行if语句中泡出异常的操作。</p><p>但是如果我们使用内部类ListItr自身提供的修改方法，则不会抛出ConcurrentModificationException异常，因为这些方法实现会更新expectedModCount的值。</p><h2 id="Fail-safe-case"><a href="#Fail-safe-case" class="headerlink" title="Fail-safe case"></a>Fail-safe case</h2><p>和fail-fast的迭代器不同，fail-safe类迭代器遍历集合时，如果对集合进行修改，会拷贝一份集合元素的副本，在副本上进行修改，所以不会抛出异常。以CopyOnWriteArrayList为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; data = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">    data.add(<span class="number">1</span>);</span><br><span class="line">    data.add(<span class="number">2</span>);</span><br><span class="line">    data.add(<span class="number">3</span>);</span><br><span class="line">    Iterator&lt;Integer&gt;iterator = data.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        Integer a = iterator.next();</span><br><span class="line">        <span class="keyword">if</span> (a==<span class="number">2</span>)&#123;</span><br><span class="line">            data.add(<span class="number">4</span>); <span class="comment">//modify while traverse over the collection.</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(String.valueOf(a)+<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://images.zhulk3.xyz/tech/3242.png" alt="结果"></p><p>即时我们在遍历过程中对集合进行了添加元素，也不会体现在遍历结果中，因为是在另一个副本中进行添加的。</p><h2 id="Fail-safe-internal-working"><a href="#Fail-safe-internal-working" class="headerlink" title="Fail-safe internal working"></a>Fail-safe internal working</h2><p>看一下是如何对副本进行操作的，以add方法为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray(); <span class="comment">//return array, which store the element.</span></span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>); <span class="comment">//array length incremented to original length + 1, and copy the original elements to newElement array.</span></span><br><span class="line">        newElements[len] = e; <span class="comment">//the last solt is e, which we want to add.</span></span><br><span class="line">        setArray(newElements); <span class="comment">//set the original array reference to newElements.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见添加元素是重新开辟了一份数组空间，添加了元素之后再修改数组引用。CopyOnWriteArrayList的迭代器遍历的却是原来的数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> COWIterator&lt;E&gt;(getArray(), <span class="number">0</span>); <span class="comment">//getArray() return the original array reference.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">COWIterator</span><span class="params">(Object[] elements, <span class="keyword">int</span> initialCursor)</span> </span>&#123;</span><br><span class="line">    cursor = initialCursor;</span><br><span class="line">    <span class="comment">//traverse the array by snapshot, the snapshot is the original array. elements may receive new array </span></span><br><span class="line">    <span class="comment">//value, so we need use snapshot to store its reference.</span></span><br><span class="line">    snapshot = elements; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，使用CopyOnWriteArrayList的缺点也是明显的，首先，由于在副本上进行修改操作，遍历其上的迭代器不能反映出其最新的状态，其次，需要一份额外的内存空间，还需要对元素进行拷贝迁移，这也是很耗费性能的，所以应该尽量在读多写上的场景进行使用。</p><p><em>参考文献</em></p><p><a href="https://anmolsehgal.medium.com/fail-fast-and-fail-safe-iterations-in-java-collections-11ce8ca4180e">Fail-fast and Fail-safe iterations in Java Collections</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术积累 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RN开发小结</title>
      <link href="/2022/03/24/RN%E5%BC%80%E5%8F%91%E5%B0%8F%E7%BB%93/"/>
      <url>/2022/03/24/RN%E5%BC%80%E5%8F%91%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="RN开发小结"><a href="#RN开发小结" class="headerlink" title="RN开发小结"></a>RN开发小结</h1><h2 id="什么是RN"><a href="#什么是RN" class="headerlink" title="什么是RN"></a>什么是RN</h2><p>React Native是Facebook基于React 开源的移动端开发框架，React是一个通过声名式UI构建组件的JavaScript库，React Native结合了原生的流畅和React的特性，是目前比较流行的移动端开发框架之一。通过声明组件，组合这些组件，完成App开发的复杂功能，这些组件虽然都是使用JavaScript开发，但是最终渲染都会使用原生API，所以渲染的流畅程度并不会太差。</p><h2 id="为什么使用RN"><a href="#为什么使用RN" class="headerlink" title="为什么使用RN"></a>为什么使用RN</h2><ul><li>RN具备跨端的特性，目前支持iOS和Android。目前大多数公司的移动端应用都会在iOS和Android两个平台上同时开发，开发一个feature或者修复一个bug，通常需要两个开发人员。使用React Native，开发的程序可以兼容两个平台，虽然有一些差异需要针对特定平台处理，但是还是可以节约一部分开发人力。</li><li>灵活更新，不需要等待发版。使用React Native开发的程序，会被打成bundle，供用户下载使用，不需要等待发版周期，这对于一些紧急需求是非常必要的。而且对于iOS的应用，很多时候应用商店会审核不过，导致用户很难体验到新的功能。一些线上bug可能需要发布热更新或者只能等待下一版本修复，但是React Native可以灵活修复，修复版本可以覆盖几乎所有用户。</li><li>对于开发人员来说，React Native基本上实现了所见即所得，一次修改，快速检验效果，这相比native开发所需要的漫长打包时间，大大提升了开发体验。</li></ul><h2 id="Key-Tech"><a href="#Key-Tech" class="headerlink" title="Key Tech"></a>Key Tech</h2><p>React Native通过声明式UI开发组件，然后组合组件开发出更加复杂的组件。组件分为函数式组件和类组件，函数式组件是无状态组件，类组件具备自己的状态和生命周期方法，后来为了减少类组件中各种生命周期方法的样板代码和复用状态的困难，提供了Hook，使得可以使用函数组件使用state和生命周期等特性。</p><ul><li><p>useState，这是一个hook，我们可以通过它为组件存储一个状态，并在适当的时机修改它。对于一般的变量，函数退出后它就会消失，但是对于useState定义的变量，会被保留。</p></li><li><p>useEffect，可以将其看作以下三个函数的组合，当组件渲染完成以后，我们可能需要执行一些操作，那我们可以将这些操作放到useEffect中调用，useEffect会保存传递的函数，在每次渲染以后调用。有一些操作是需要在组件unmount之后删除的，防止内存泄露，可在useEffect的return语句中返回，进行删除。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;&#125;  </span><br><span class="line"><span class="function"><span class="title">componentDidUpdate</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>​    </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Have a timer call the function every 5 seconds using setInterval</span></span><br><span class="line">    <span class="keyword">const</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;&#125;, <span class="number">5000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure></li><li><p>useRef可以用来返回一个可变的ref对象，对象的改变不会触发组件的重新渲染，在整个组件生命周期内是唯一的。</p></li><li><p>useMemo，useMemo返回类型不限的值，只有当依赖项变化时才会触发重新计算，</p></li><li><p>useCallBack，返回可被记忆的回调，每次依赖项改变时，都能生成新的回调。</p></li></ul><h2 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h2><p>1、在实现两个组件重叠的效果中，往往需要使用绝对定位。使用绝对定位的的组件会脱离文档流，以最近的父布局作为参考，决定位置。但是这必须要指定其自身的高度或者宽度。</p><p>2、使用绝对定位有可能使组件被置于其他组件之下，导致点击事件被屏蔽，可以通过动态修改pointer-events属性来决定是否拦截点击事件。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://segmentfault.com/a/1190000021261588">React Hook</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术积累 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的同步原语</title>
      <link href="/2022/02/10/Java%E4%B8%AD%E7%9A%84%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD/"/>
      <url>/2022/02/10/Java%E4%B8%AD%E7%9A%84%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>volatile可以保证修饰变量的可见性和有序性，对于被volatile修饰的变量，对其进行单个读写，等价于被synchronized修饰的读操作或者写操作。</p><h2 id="如何保证可见性"><a href="#如何保证可见性" class="headerlink" title="如何保证可见性"></a>如何保证可见性</h2><p>实现情况视处理器而定，在intel处理器上，对被volatile修饰的变量进行写操作的指令，在翻译为汇编指令时，会加上lock前缀，处理器在执行这一指令时，会将缓存行中的数据写会内存，其他CPU会通过嗅探总线，如果本地内存内缓存了此变量，会时当前值无效，重新读取。</p><h2 id="如何保证有序性"><a href="#如何保证有序性" class="headerlink" title="如何保证有序性"></a>如何保证有序性</h2><p>在对volatile进行读写操作指令在编译为字节码时，会通过在指令序列中插入内存屏障指令来预防编译器和处理器为提高执行效率而进行的指令重排序，以此保证执行的有序性。</p><h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><p>java中的每一个对象都可以作为锁，使用synchronized加锁，根据使用场景，有三种不同的情况：</p><ul><li>对于普通同步方法，锁是实例对象；</li><li>对于同步代码块，锁是当前类的Class对象（访问当前类方法和属性的入口）；</li><li>对于同步方法块，锁是括号中配置的对象。<br>synchronized用的锁是存在Java对象头里的，Java对象头中的Mark Word默认存储对象的hashCode，分段年龄和锁标记位。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8fd683f43cdf48fb96e5ca44fb8d6832~tplv-k3u1fbpfcp-watermark.image" alt="lock.png"></p><h1 id="fianl域的内存语义"><a href="#fianl域的内存语义" class="headerlink" title="fianl域的内存语义"></a>fianl域的内存语义</h1><p>编译器和处理器对于final域的的处理，在进行重排序时需要遵守两个规则：</p><ul><li>在构造函数内对一个final域的写入与随后将这个引用赋值给其他引用的操作不能重排；</li><li>初次读一个包含final域对象的引用，与随后读这个final域，不能重排。<br>实现以上规则同样是依赖在字节码指令序列中插入内存屏障。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术积累 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的锁</title>
      <link href="/2022/02/10/Java%E4%B8%AD%E7%9A%84%E9%94%81/"/>
      <url>/2022/02/10/Java%E4%B8%AD%E7%9A%84%E9%94%81/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Condition接口"><a href="#Condition接口" class="headerlink" title="Condition接口"></a>Condition接口</h1><p>synchronized关键字配合Object类提供的wait(), wait(long timeout),notify(), notifyAll()等方法，可以实现等待&#x2F;通知模式。Condition接口也提供了类似的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line"><span class="comment">//进入等待状态，直到其他线程调用signal()或者signalAll()方法进行唤醒。或者其他线程中断当前线程。如果当前线程返回，则已经重新获得锁。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不可中断</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//超时后返回，单位为毫秒</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//超时后返回，单位为 TimeUnit中的枚举</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//超时到将来的具体时间</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//唤醒一个线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//唤醒所有线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h1><p>synchronized进行加锁时，都是隐式加锁，不容易因为释放锁导致出错，Lock接口需要显式加锁，更加灵活。Lock接口具备synchronized关键字所不具备的灵活性：</p><ul><li>超时加锁，在指定时间内如果尚未获取到锁，返回false，如果在超时等待的时间内被中断，则抛出异常，获取到锁则返回true。</li><li>可以响应中断，在线程获取锁的过程中，可以响应中断，避免死锁发生。</li><li>非阻塞的获取锁，使用synchronized加锁，如果没有获得锁，则会进入阻塞状态，Lock加锁则是进入等待状态。</li></ul><h1 id="AbstractQueuedSychronizer"><a href="#AbstractQueuedSychronizer" class="headerlink" title="AbstractQueuedSychronizer"></a>AbstractQueuedSychronizer</h1><p>AQS的设计是基于模版方法mo模式的，使用者需要继承AQS，重写指定的方法，然后组合到同步组件当中使用。同步组件对外提供的调用方法，可以委托给AQS子类具体执行。</p><h2 id="AQS的使用"><a href="#AQS的使用" class="headerlink" title="AQS的使用"></a>AQS的使用</h2><p>同步器提供了三个方法，可以线程安全的访问同步的状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体同步组件只需视情况实现以下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//独占式获取同步状态，在具体实现中，需要原子判断当前state是否符合预期（为旧值，其他线程未修改），如果符合，将状态设置为新值。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">long</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放同步状态</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">long</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//共享式获取</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">long</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//共享式释放</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">long</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断当前状态是否被独占</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步组件对外提供了一些模版方法，供外部查询和操作同步状态，这些方法可以支持超时和中断的独占式获取和共享式获取同步状态。值得注意的是，这些方法都已经被final修饰，不可重写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AQS的实现"><a href="#AQS的实现" class="headerlink" title="AQS的实现"></a>AQS的实现</h2><h3 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h3><p>同步器依赖内部的同步队列来完成同步状态的管理，当前线程获取同步状态失败时，会将当前线程以及等待状态信息构成一个Node加入到队尾，同时会阻塞当前线程，当同步状态被释放时，会从队列首部唤醒节点中的线程，使其尝试获取同步状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NOde的部分字段</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AQS使用同步队列维护获取同步状态失败而阻塞的的线程，head指向头节点，每次获取状态失败的线程构成节点以后加入队列尾部。首节点是获取到同步状态的线程，当其释放同步状态时，会将首节点设置为其后继节点。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dddceba90c964928b97828668ad86ce7~tplv-k3u1fbpfcp-watermark.image" alt="tail.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetHead</span><span class="params">(Node update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, headOffset, <span class="keyword">null</span>, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CAS tail field. Used only by enq.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetTail</span><span class="params">(Node expect, Node update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, tailOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术积累 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConcurrentHashMap</title>
      <link href="/2022/02/10/ConcurrentHashMap/"/>
      <url>/2022/02/10/ConcurrentHashMap/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="为什么使用ConcurrentHashMap"><a href="#为什么使用ConcurrentHashMap" class="headerlink" title="为什么使用ConcurrentHashMap"></a>为什么使用ConcurrentHashMap</h1><p>HashMap是线程不安全的，在多线程执行put操作过程中，有可能会试容量达到阈值，触发扩容操作，HashMap的扩容操作会将数组容量扩大为当前数组长度的两倍，重新遍历HashMap，将每一个链表中的元素进行重新hash，存入新的HashMap中。如果是多线程进行put，会出现链表成环，导致HashMap的get操作无法结束，CPU利用率达到100%；<a href="https://juejin.cn/post/6844903554264596487">老生常谈，HashMap的死循环</a></p><p>HashTable几乎提供了与HashMap相同的操作，但是HashMap的很多方法都是通过synchronized修饰的，多线程操作会导致线程阻塞，即便是多个只进行查询操作的线程，这样使得效率非常低下。</p><p>我们可以使用Collections提供的封装方法，得到线程安全的Map。但是看了下面SynchronizedMap的实现，是使用了一个Object对象作为锁，同样每一个操作方法都被synchronized修饰了，可见效率也不高。如果需要线程安全且比较高效的HashMap，可以使用ConcurrentHashMap。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; <span class="function">Map&lt;K,V&gt; <span class="title">synchronizedMap</span><span class="params">(Map&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SynchronizedMap&lt;&gt;(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="为什么ConcurrentHashMap是线程安全的"><a href="#为什么ConcurrentHashMap是线程安全的" class="headerlink" title="为什么ConcurrentHashMap是线程安全的"></a>为什么ConcurrentHashMap是线程安全的</h1><p>ConcurrentHashMap是由Segment数组和HashEntry数组组成的，Segment是一种可重入锁，HashEntry用于存储键值对数据。一个Segment包含一个HashEntry数组，每个HashEntry是一个链表结构，每个Segment守护一个HashEntry数组的元素，当需要对数组中的元素进行修改时，必须先获得对应Segment的锁。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39ed62b8e2d847d3a683344da92061cd~tplv-k3u1fbpfcp-watermark.image" alt="struct.png"></p><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><ul><li>初始化segments数组，通过conrencyLevel计算数组长度，必须是2的整数幂。</li><li>初始化segmentShift和segmentMask，segmentShift用于定位参与散列运算的位数，segmentMask是参与与hash做与运算的掩码，为size-1.</li><li>初始化每一个segment，每一个HashEntry长度同样需要是2的整数幂长度。</li></ul><h1 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h1><p>get操作是不需要获取锁的，因为每一个HashEntry节点的value已经被volatile修饰了，可以保证读到的值是最新的值。<br>定位节点分为两步，首先定位目标segment，然后再定位具体的节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hash &gt;&gt;&gt; segmentShift) &amp; segmentMask  <span class="comment">// 定位Segment所使用的hash算法 </span></span><br><span class="line"><span class="keyword">int</span> index = hash &amp; (tab.length - <span class="number">1</span>);  <span class="comment">// 定位HashEntry所使用的hash算法</span></span><br></pre></td></tr></table></figure><h1 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h1><p>在进行put操作时，首先定位到具体的segment，会对当前segment进行加锁，然后判断是否需要扩容，如果需要扩容，只对当前segment执行扩容操作，最后再添加元素，这不同于HashMap，HashMap添加节点以后进行扩容，如果以后都不再添加元素，这也许是一次无效扩容。</p><h1 id="查询size"><a href="#查询size" class="headerlink" title="查询size"></a>查询size</h1><p>每个Segment使用volatile维护了一个表示当前segment内元素数量的count，但是显然对每个segment中count进行求和的操作不是原子性的。ConcurentHashMap还维护了一个变量，modCount，每次对ConcurrentHashMap中元素的修改操作会使得当前变量加1，所以在对count进行求和之前，保留modCount的副本，在求和以后如果modCount没有发生变化，证明求和这段时间没有线程对容器内元素进行操作，对count的求和是可靠的，如果modCount发生了改变，则需要重新求和，连续两次容器的大小都没有成功正确统计到，则对所有的segment加锁然后求和。</p>]]></content>
      
      
      <categories>
          
          <category> 技术积累 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合框架的使用</title>
      <link href="/2022/02/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/02/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>Java集合框架是一类用来存放元素的容器，主要分为实现了Map接口和实现了Collection接口的两类，前者存放的元素是一对key-value的映射，要求key唯一，后者存放的是单个元素，其中实现了Set接口的容器要求容器中的元素不可重复。</p><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>所谓泛型，就是类型参数话，集合框架下定义的容器希望不被局限于某一类元素，而是一套通用框架，可以存放除基本类型以为的其他类型。在集合容器变量声明时使用某一类型，那么此容器就只能存放这一类型的元素，并且容器中的元素可以调用这一类型元素可以调用的方法。</p><h1 id="Collection类"><a href="#Collection类" class="headerlink" title="Collection类"></a>Collection类</h1><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/962ea9d1d3144161adfcd91ff54b6792~tplv-k3u1fbpfcp-watermark.image" alt="collection.png"></p><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>ArrayList是通过数组实现的List，具有快速随机查找的特点，但是删除元素和插入元素效率较低。常用的API有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object[] <span class="title">toArray</span><span class="params">()</span> <span class="comment">//返回一个包含当前所有元素的数组</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> <span class="comment">//在指定下标插入元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> <span class="comment">//删除指定下标的元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> <span class="comment">//在当前列表后依次添加c中的元素</span></span></span><br></pre></td></tr></table></figure><p>ArrayList实现了Cloneable接口，可以实现存储元素引用的浅拷贝，即两个容器中引用对象仍然相同，实现了Serializable接口，支持序列化和反序列化。</p><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p>使用链表实现，每个节点item引用对象，和next，pre两个指针。LinkedList实现了Deque接口，可以从链表双端对链表进行操作。由于实现方式是链表，所以LinkedList具有插入和删除比较快，随机访问较慢的特点。LinkedList具有很多双端操作链表的API，可以认为如果不带显式的first和last方法，那么删除元素默认在链表尾部进行，添加元素在链表头部进行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeLastOccurrence</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeFirstOccurrence</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> <span class="comment">//删除链表首部元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekFirst</span><span class="params">()</span> <span class="comment">//取得链表头节点</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekLast</span><span class="params">()</span>  <span class="comment">//取得链表尾节点</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e)</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure><p>LinkedList不是线程安全的，如果有多个线程同时对LinkedList的结构进行修改（增加或者删除节点），有可能会导致链表出现环状。可以使用如下方法进行包装得到线程安全的List。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list)</span><br></pre></td></tr></table></figure><h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p>Vector是线程安全的，有可能引起线程不安全的操作和获取相关Vector信息的值的方法都被synchronized修饰了。但是在不要求线程安全的场景下，推荐使用ArrayList代替Vector，性能更好。</p><h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><p>Stack是继承自Vector的集合，具有后进先出的特点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">push</span><span class="params">(E item)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">peek</span><span class="params">()</span> </span></span><br></pre></td></tr></table></figure><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p>HashSet实现了Set接口，可以保证元素的容器中元素唯一，但是不保证有序。HastSet是通过<a href="https://juejin.cn/post/7044795520031653925">HashMap</a>实现的，保证容器中元素唯一的方式是，每次插入的元素实际是作为(key,value)中的key，value是一个Object对象，HashMap是可以保证存入元素key是唯一的，所以HashSet能够保证容器中的元素唯一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashSet同样是线程不安全的，如果需要在多线程场景中使用hashSet，推荐如下封装：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set s = Collections.synchronizedSet(<span class="keyword">new</span> HashSet(...));</span><br></pre></td></tr></table></figure><h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><p>继承自HashSet，与HashSet相同，可保证元素唯一，使用LinkedHashMap实现，可以保证插入元素顺序可知。</p><h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><p>实现了SortedSet接口，可以保证容器内元素不重复，可排序。</p><h1 id="Map类"><a href="#Map类" class="headerlink" title="Map类"></a>Map类</h1><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/554b9ade16d14634ad00752ada96d6df~tplv-k3u1fbpfcp-watermark.image" alt="map.png"><br>实现了Map接口的容器类用来存放的元素是一组key到value的映射关系，LinkedHashMap继承自HashMap，可以在HashMap的基础上保证存入顺序是可知的。</p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a><a href="https://juejin.cn/post/7044795520031653925">HashMap</a></h2><h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LinkedHashMap实现这一功能的方式是，其中的每一个节点，都有两个指针，before和after，分别指向前一个插入节点，和后一个插入的节点。</p><p>LinkedhashMap是如何保证插入顺序有序的？重写了HashMap的newNode方法，将当前插入节点的before指针指向了插入前的尾节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        <span class="keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">    tail = p;</span><br><span class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">        head = p;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Integer&gt; scores = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">    scores.put(<span class="string">&quot;chemistry&quot;</span>, <span class="number">93</span>);</span><br><span class="line">    scores.put(<span class="string">&quot;math&quot;</span>, <span class="number">98</span>);</span><br><span class="line">    scores.put(<span class="string">&quot;biology&quot;</span>, <span class="number">92</span>);</span><br><span class="line">    scores.put(<span class="string">&quot;english&quot;</span>, <span class="number">97</span>);</span><br><span class="line">    scores.put(<span class="string">&quot;physics&quot;</span>, <span class="number">94</span>);</span><br><span class="line">    scores.put(<span class="string">&quot;chinese&quot;</span>, <span class="number">99</span>);</span><br><span class="line">    scores.put(<span class="string">&quot;geography&quot;</span>, <span class="number">95</span>);</span><br><span class="line">    Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = scores.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        Map.Entry&lt;String, Integer&gt; score = iterator.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;subject: &quot;</span> + score.getKey() + <span class="string">&quot; score: &quot;</span> + score.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38bec6196f504c888b765e176676281d~tplv-k3u1fbpfcp-watermark.image" alt="map_answer.png"></p><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>基于红黑树实现的，对可对key进行排序的NavigableMap。</p><p>reference：<br><a href="https://zhuanlan.zhihu.com/p/34490361">https://zhuanlan.zhihu.com/p/34490361</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术积累 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap的使用</title>
      <link href="/2022/02/10/HashMap%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/02/10/HashMap%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="Node和初始化"><a href="#Node和初始化" class="headerlink" title="Node和初始化"></a>Node和初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//hashCode通过key于value计算得到</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>哈希桶的大小，默认为16，如果自定义，需要为2的n次幂，这样可以使用与运算高效的代替模运算。</li><li>负载因子，负载因子*数组长度等于容量阈值。</li><li>阈值，当前HashMap中元素元素超过阈值，需要扩容，防止各种操作hash冲突增多，效率变低。<h2 id="hash和寻址"><a href="#hash和寻址" class="headerlink" title="hash和寻址"></a>hash和寻址</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line">index = hash&amp;(tab.length-<span class="number">1</span>);</span><br></pre></td></tr></table></figure>hash值通过key的hashCode异或本身高位得到的，这样可以让高位参与运算，否则hash值异或(tab.length-1)将不能利用hash值的高位，导致hash冲突变多。</li></ul><h2 id="put过程"><a href="#put过程" class="headerlink" title="put过程"></a>put过程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) <span class="comment">//判断数组位置是否已经插入元素，如果没有就插入数组中</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) <span class="comment">//通过hash和key确定，是否key相同，是的话覆盖value即可</span></span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">//判断是不是转为了红黑树，是的话将此节点插入树中</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//循环遍历链表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123; <span class="comment">//到达尾部，没有找到key相同的节点，插入尾部</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="comment">//找到key相同的节点，直接返回，执行1</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1，在key相同的节点，修改value</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//size大于阈值，扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="get过程"><a href="#get过程" class="headerlink" title="get过程"></a>get过程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) <span class="comment">//首先通过hash值在哈希表数组中寻找，如果hash和key都符合，则表示找到，可以返回</span></span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123; <span class="comment">//出现hash冲突，</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)<span class="comment">//如果子节点是树节点，在红黑树中寻找</span></span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123; <span class="comment">//循环遍历链表，在链表中查找</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>在容量超过阈值以后，会进行扩容，数组容量是当前数组的两倍。扩容后会为当前HashMap中每一个桶中的元素重新寻址，新的下标是e.hash&amp;(newCapcity-1)。如果新的hash桶中已有元素，则类似插入元素的方式将当前元素插入hash表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        next = e.next;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123; <span class="comment">//决定存在数组高位还是低位</span></span><br><span class="line">            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                loTail.next = e; <span class="comment">//会形成一个链表，link_1;</span></span><br><span class="line">            loTail = e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;  <span class="comment">//也会形成一个链表，link_2;</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">            hiTail = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">        newTab[j] = loHead; <span class="comment">//存link_1在新数组低位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">        newTab[j + oldCap] = hiHead; <span class="comment">//存link_2在数组高位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术积累 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Executor框架的使用</title>
      <link href="/2022/02/10/Executor%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/02/10/Executor%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>在Executor框架中，工作单元包括Runnable和Callable，执行机制由Executor框架提供。</p><h2 id="两层调度模型"><a href="#两层调度模型" class="headerlink" title="两层调度模型"></a>两层调度模型</h2><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b99fd61c3af04612a63ef8cc00292289~tplv-k3u1fbpfcp-watermark.image" alt="executor.png"></p><p>多线程程序将任务分解为多个任务，然后由用户级调度器Executor将这些任务交由Java线程执行。Java线程并不是直接被CPU调度执行，还会映射为操作系统内核线程，由内核调度器将内核线程调度到CPU执行。祥见<a href="https://www.kancloud.cn/zhangchio/news/754628">Java线程和os线程</a></p><h2 id="Exectuor框架的结构"><a href="#Exectuor框架的结构" class="headerlink" title="Exectuor框架的结构"></a>Exectuor框架的结构</h2><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7dc4064f4fbd406698cb1d25657c3a42~tplv-k3u1fbpfcp-watermark.image" alt="worker.png"></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/249b3e055ce14c6897c9423fc3531b7a~tplv-k3u1fbpfcp-watermark.image" alt="manager.png"><br>Executor框架由三大部分组成：</p><ul><li>任务，包括被执行任务需要实现的接口，Runnable接口和Callable接口；</li><li>任务的执行，任务机制的和讯即接口及其实现类，ThreadPoolExecutor和ScheduledThreadPool;</li><li>异步计算的结果，Future及其实现类FutureTask；</li></ul><h3 id="Executor框架的使用"><a href="#Executor框架的使用" class="headerlink" title="Executor框架的使用"></a>Executor框架的使用</h3><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/111948a08b1a4519b063a97bc121047d~tplv-k3u1fbpfcp-watermark.image" alt="use.png"><br>主线程创建一个Runnable或者Callable任务（Executor可以将Runnable类型转换为Callable类型），然后交给Executor执行，主线程通过返回的Future接口，阻塞等待任务执行以后返回结果，也可以在等待过程中取消任务执行。</p><h3 id="Executor框架核心类"><a href="#Executor框架核心类" class="headerlink" title="Executor框架核心类"></a>Executor框架核心类</h3><ul><li>ThreadPoolExecutor，线程池的核心实现类，用来执行被提交的任务。通过工厂类Executors实现三种类型线程池：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//核心线程数和最大工作线程数量相等，避免创建大量线程，适用于服务器负载较重的情况。</span></span><br><span class="line"><span class="comment">//使用无界队列LinkedBlockingQueue作为任务管理队列，意味着线程池中工作线程不会超过核心线程。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//没有核心线程，最大工作线程取整数的最大值，适用于有比较多短期的小任务场景；</span></span><br><span class="line"><span class="comment">//使用SynchronousQueue作为工作队列，当主线程提交任务速度大于线程处理速度时，会不断创建线程，有可能会因为创建过多线程导致CPU和内存耗尽</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只会创建一个工作线程，适用于需要保证顺序的执行各个任务的场景。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ScheduledThreadPoolExecutor用于在固定延迟后执行任务，通过Executors创建，包括两种类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只会创建单个核心线程，工作线程为Integer.MAX_VALUE</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DelegatedScheduledExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>, threadFactory));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以设置多个核心线程,工作线程为Integer.MAX_VALUE</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Runnable接口和Callable接口的实现类，都可以交个线程池执行，不同的是Callable接口可以返回结果.也可以将一个Runnable对象封装为Callable对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">callable</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RunnableAdapter&lt;T&gt;(task, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用DelayWorkerQueue作为工作队列，这是一个无界阻塞队列，使用PriorityQueue实现。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue(), threadFactory, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d0498dc7cd647109a4b33eb05b8c507~tplv-k3u1fbpfcp-watermark.image" alt="schedule.png"><br>主线程向DelayWorkerQueue中添加任务时，任务会被包装为ScheduledFutureTask，线程池中的线程会从队列中取出任务执行。</p><h3 id="ScheduledThreadPoolExecutor的实现"><a href="#ScheduledThreadPoolExecutor的实现" class="headerlink" title="ScheduledThreadPoolExecutor的实现"></a>ScheduledThreadPoolExecutor的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ScheduledFutureTask(Callable&lt;V&gt; callable, <span class="keyword">long</span> ns) &#123;</span><br><span class="line">    <span class="keyword">super</span>(callable);</span><br><span class="line">    <span class="keyword">this</span>.time = ns; <span class="comment">//表示这个任务将要被执行的具体时间</span></span><br><span class="line">    <span class="keyword">this</span>.period = <span class="number">0</span>; <span class="comment">//表示任务执行的间隔周期，</span></span><br><span class="line">    <span class="keyword">this</span>.sequenceNumber = sequencer.getAndIncrement(); <span class="comment">//被添加入任务队列的顺序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DelayQueue中的任务是ScheduledFutureTask类型，包括三个成员变量。DelayQueue封装了一个PriorityQueue，会根据ScheduledFutureTask的time和sqquenceNumber进行排序。线程池中的线程会从任务队列中取出time大于当前时间的任务进行执行。在执行结束以后，会更新time，重新将任务放回队列之中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setNextRunTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> p = period;</span><br><span class="line">    <span class="keyword">if</span> (p &gt; <span class="number">0</span>)</span><br><span class="line">        time += p;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        time = triggerTime(-p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p>由于FutureTask继承了Future接口和Runnable接口，所以可以把一个FutureTask接口交由实现了Executor的线程池执行，也可以作为计算结果返回,然后执行FutureTask.get()阻塞当前线程等待返回计算结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);</span><br></pre></td></tr></table></figure><p>FutureTask是基于AbstractQueuedSynchronizer（AQS）实现的，很多可阻塞类都是基于AQS实现的，AQS是一个原子框架，提供了通用机制来原子性的管理状态，阻塞和唤醒线程，以及维护被阻塞线程的队列。对于很多阻塞类，其具体操作都会委托给实现了AQS的内部类Sync，由Sync进行具体的操作。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53f063b85502467189b0decd26a66027~tplv-k3u1fbpfcp-watermark.image" alt="aqs.png"></p>]]></content>
      
      
      <categories>
          
          <category> 技术积累 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池的使用</title>
      <link href="/2022/02/10/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/02/10/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="使用线程池的益处"><a href="#使用线程池的益处" class="headerlink" title="使用线程池的益处"></a>使用线程池的益处</h2><ul><li>避免重复创建线程执行任务，减少了创建线程和销毁线程需要的时间开销和性能开销；</li><li>提高任务响应速度，线程池中通常缓存有线程，当提交任务以后，可迅速执行；</li><li>避免了无规则的创建大量线程，导致大量线程排队等待CPU，响应速度变慢；</li></ul><h2 id="线程池处理流程"><a href="#线程池处理流程" class="headerlink" title="线程池处理流程"></a>线程池处理流程</h2><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/59976e0fd2fe42d9862b3db3be1aa4d1~tplv-k3u1fbpfcp-watermark.image" alt="stage.png"></p><p>我们可以调用线程池的execute和submit方法来提交任务，提交参数都是一个Runnable实例，不同的是，submit会返回一个Future类型的对象，可以通过future对象的get方法获得返回值，注意这个方法会阻塞当前线程。</p><ol><li>当一个任务提交给线程池时，如果当前线程池中线程数量少于核心线程数，会重新创建新的线程执行这个任务，然后通过线程安全的方法更新当前线程数。注意，当提交一个任务给线程池时，线程池会创建一个核心线程来执行，即使其他核心线程空闲，直到核心线程达到预设值。</li><li>如果当前线程数已经大于或者等于核心线程数，那会尝试判断阻塞队列是否已满，未满的话将任务加入到阻塞队列中。</li><li>已满则判断当前线程池数量是否小于最大线程数量，如果是的话，创建工作线程执行，否则的话执行拒绝策略。</li></ol><h2 id="线程池参数说明"><a href="#线程池参数说明" class="headerlink" title="线程池参数说明"></a>线程池参数说明</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,//核心线程数</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">int</span> maximumPoolSize, //最大工作线程数，不能小于corePoolSize</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">long</span> keepAliveTime, //非核心线程超时时间，闲置时间超过会被销毁</span></span></span><br><span class="line"><span class="params"><span class="function">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                          BlockingQueue&lt;Runnable&gt; workQueue, //用于保存等待执行的任务的阻塞队列</span></span></span><br><span class="line"><span class="params"><span class="function">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                          RejectedExecutionHandler handler //拒绝策略)</span></span></span><br></pre></td></tr></table></figure><p>阻塞队列有很多种,newCachedThreadPool使用SynchronousQueue，这种阻塞队列不存储任务，每个插入操作必须等待一个线程执行取出操作，否则插入线程阻塞。newFixedThreadPool则使用LinkedBlockingQueue。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a92003860de484f9303698e8db22999~tplv-k3u1fbpfcp-watermark.image" alt="handle.png"></p><p>拒接策略分为四种，分别是直接只用调用者所在线程执行任务、直接抛出异常、丢弃队列里等待最长时间的任务，执行当前任务、或者直接丢弃掉当前任务。</p><h2 id="配置线程池"><a href="#配置线程池" class="headerlink" title="配置线程池"></a>配置线程池</h2><p>根据不同的情况配置线程池：</p><ul><li>根据任务性质，比如是CPU密集型还是IO密集型，CPU密集型应该配置尽可能少的线程，防止线程持续等待CPU分配时间，IO密集型就可以多一些线程，因为大部分线程可能在等待IO；</li><li>任务优先级，是否有些任务是高优执行的，可以使用ProrityQueue作为阻塞队列。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术积累 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的并发工具类</title>
      <link href="/2022/02/10/Java%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
      <url>/2022/02/10/Java%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>Java中有许多工具类可以在并发场景中使用，简化并发编程难度，提高程序准确性。</p><h2 id="CountDaowLatch"><a href="#CountDaowLatch" class="headerlink" title="CountDaowLatch"></a>CountDaowLatch</h2><p>可以实现类似于fork-join模型提供的功能，在多线程场景中，用于等待其他线程完成的线程可以调用countDownLatch的await方法进入等待状态，只有当其他线程将CountDownLatch中保存的值递减到0时，等待线程才会继续运行。</p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>)；</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread threadOne = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;continue&quot;</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                System.out.println(<span class="string">&quot;continue&quot;</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadOne.start();</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f273d1dd6c2147cdb5145ee3dfa042ac~tplv-k3u1fbpfcp-watermark.image" alt="answer.png"></p><p>运行结果总是相同，主线程在运行到await时，会进入等待状态，只有当子线程两次执行完countDown之后，主线程才会继续执行。</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>查看CountDownLatch的实现，可以看到在new一个CountDownLatch时，需要一个int类型的参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;count &lt; 0&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Sync是CountDownLatch的一个继承了AbstractQueuedSynchronizer的内部类，用于实现同步控制，具有一些列加锁和解锁的方法。构造CountDownLatch时传入的参数最终用来设置一个被volatile修饰的属性state。这个state值可以理解了当前所有线程可重入的获得了多少锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>countDown会将当前的state值减1，这可以理解为释放一把锁的过程。</p><p>当主线程调用await方法之后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果当前的state没有减到0，主线程就会去执行doAcquireSharedInterruptibly,这个方法会使得主线程不断死循环的去获取“锁”，或者直到中断，直到state减少到0，主线程才能得到“锁”，解除循环，继续执行。</p><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><h3 id="使用方式-1"><a href="#使用方式-1" class="headerlink" title="使用方式"></a>使用方式</h3><p>可以用于做流量控制，限制多线程对有限资源的访问，在多并发场景下，如果资源数量有限，只能够支持有限的线程的使用，可以使用信号量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_COUNT = <span class="number">30</span>; <span class="comment">//线程规模</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore s = <span class="keyword">new</span> Semaphore(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span> * THREAD_COUNT; i++) &#123; <span class="comment">//任务数量远大于线程数</span></span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        s.acquire();  <span class="comment">//获取信号量</span></span><br><span class="line">                        printThreadCount();</span><br><span class="line">                        s.release(); <span class="comment">//释放信号量</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">printThreadCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前可用许可证数：&quot;</span>+s.availablePermits() + <span class="string">&quot; 等待线程数&quot;</span> + s.getQueueLength());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d5e7abb9e634cf0833e479611c11b0b~tplv-k3u1fbpfcp-watermark.image" alt="ww.png"></p><h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">    setState(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在初始化Semaphore时，默认构造非公平的同步器，传入参数为信号量的值。<br>在线程执行到acquire时，会尝试可中断的去获取信号量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)    </span><br><span class="line">        doAcquireSharedInterruptibly(arg);  <span class="comment">//1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> available = getState();</span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires;<span class="comment">//目前剩余信号量，小于0证明已经无可用</span></span><br><span class="line">        <span class="comment">//尝试判断，小于0或者原子重置信号量值失败，都会返回负值，然后进入等待队列</span></span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在释放信号量以后，会通过原子操作给state值加一，如果当前state的值大于0，会在等待队列中唤醒队列首部的线程去获得信号量。</p>]]></content>
      
      
      <categories>
          
          <category> 技术积累 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的原子类</title>
      <link href="/2022/02/10/Java%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E7%B1%BB/"/>
      <url>/2022/02/10/Java%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>在多线程读写共享变量的场景中，很容易出现数据竞争，导致数据不一致。Java提供了<strong>synchronized</strong>关键字和<strong>Lock</strong>接口来保证多线程对同步块的有序访问，但是这两种方式都需要隐式或者显式的获取锁，性能开销略大。Java的Atomic包提供了多个原子操作类，可以安全、高效、简单的实现在多线程场景下读写变量。Atomic包中的类基本上都是使用Unsafe实现的包装类。</p><h2 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h2><p>包括诸多方法实现整型数据的原子操作。比如对于整数的递增操作i++，由于这一操作并不是原子的，所以即便使用volatile修饰也不能保证线程安全，这种场景就可以使用AtomicInteger的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically increments by one the current value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the updated value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下通过AtomitInteger的addAndGet方法来分析这一原子类是如何实现线程安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically adds the given value to the current value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> delta the value to add</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> valueOffset the value memory address.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the updated value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">addAndGet</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, delta) + delta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>var5是通过native方法取得的当前变量的值，compareAndSwapInt通过原子操作，将预期的的结果var5+var4替换为当前变量的值var5，如果方法成功就，compareAndSwapInt返回ture，循环结束，如果返回false，说明有其他线程在这段时间修改了当前变量的值，会重新通过循环获取var5，继续重试。</p><h2 id="AtomicBoolean"><a href="#AtomicBoolean" class="headerlink" title="AtomicBoolean"></a>AtomicBoolean</h2><p>实现原理与AtomicInteger基本相同，核心思想是将true和false映射为1和0。int类型的value存储的就是当前AtomicBoolean的状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new &#123;<span class="doctag">@code</span> AtomicBoolean&#125; with the given initial value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialValue the initial value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AtomicBoolean</span><span class="params">(<span class="keyword">boolean</span> initialValue)</span> </span>&#123;</span><br><span class="line">    value = initialValue ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically sets to the given value and returns the previous value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newValue the new value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">boolean</span> newValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> prev;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = get();</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSet(prev, newValue));</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">boolean</span> expect, <span class="keyword">boolean</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> e = expect ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">//将boolean类型映射为int类型</span></span><br><span class="line">    <span class="keyword">int</span> u = update ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, e, u);<span class="comment">//通过原子操作更新当前值。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原子更新数组"><a href="#原子更新数组" class="headerlink" title="原子更新数组"></a>原子更新数组</h2><p>更新数组的值是通过调用其他原子更新基本类型或者引用类型来实现的，重点在于通过数组下标获得当前值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">updateAndGet</span><span class="params">(<span class="keyword">int</span> i, IntUnaryOperator updateFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> offset = checkedByteOffset(i);<span class="comment">//得到下标在内存中的地址</span></span><br><span class="line">    <span class="keyword">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = getRaw(offset);</span><br><span class="line">        next = updateFunction.applyAsInt(prev);<span class="comment">//转为int</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSetRaw(offset, prev, next));</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在内存中取得当前值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getRaw</span><span class="params">(<span class="keyword">long</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getIntVolatile(array, offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以原子方式修改数组偏移量的值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compareAndSetRaw</span><span class="params">(<span class="keyword">long</span> offset, <span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(array, offset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="原子更新引用"><a href="#原子更新引用" class="headerlink" title="原子更新引用"></a>原子更新引用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> longkai;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReferenceTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AtomicReference&lt;User&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;User&gt;();</span><br><span class="line">        User firstUser = <span class="keyword">new</span> User(<span class="string">&quot;long&quot;</span>, <span class="number">23</span>);</span><br><span class="line">        atomicReference.set(firstUser);</span><br><span class="line">        User secondUser = <span class="keyword">new</span> User(<span class="string">&quot;kai&quot;</span>, <span class="number">24</span>);</span><br><span class="line">        atomicReference.compareAndSet(firstUser, secondUser);</span><br><span class="line">        System.out.println(atomicReference.get().getName());</span><br><span class="line">        System.out.println(atomicReference.get().getAge());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V expect, V update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>通过查看源码，最后发现Unfase类只提供了三种CAS方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果当前值为var4，则将值更新为var5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object var1, <span class="keyword">long</span> var2, Object var4, Object var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">long</span> var4, <span class="keyword">long</span> var5)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>与AtomicBoolean类似，原子更新char、short、float、double可以实现。CAS算法是一种乐观锁的实现思想，在更新变量之前不对更新操作进行加锁，而是在更新之后再去看当前变量内存地址的值有没有发生改变，如果没有，就将希望更新的值写入到内存，如果发生了更改，则继续重试。</p>]]></content>
      
      
      <categories>
          
          <category> 技术积累 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在冬季和北京再次相遇</title>
      <link href="/2020/11/19/%E5%9C%A8%E5%86%AC%E5%AD%A3%E5%92%8C%E5%8C%97%E4%BA%AC%E5%86%8D%E6%AC%A1%E7%9B%B8%E9%81%87/"/>
      <url>/2020/11/19/%E5%9C%A8%E5%86%AC%E5%AD%A3%E5%92%8C%E5%8C%97%E4%BA%AC%E5%86%8D%E6%AC%A1%E7%9B%B8%E9%81%87/</url>
      
        <content type="html"><![CDATA[<p>昨天晚上八点到的北京，从广州穿着短袖飞越两千多公里，下飞机以后穿着和路人显得格格不入，大家都是穿着厚厚的棉袄了。</p><p>走了二十多分钟到之前订的民宿里暂住一晚，一路上是那种好久没有感觉过的冷。房东是个大学老师，很客气。十一点吃完外卖直接睡下了，感觉还是没有住酒店轻松，民宿总感觉不方便，比如担心声音大了一点惹主人家不高兴。</p><p>早上起来赶到回龙观和房东谈房子，感觉北京的空气比前些年要好很多了，很明显有那种高纬度地区天空纯洁的感觉。前几天从广州寄的被子今天刚好送到，不早不晚，可以直接用上。</p><p>秋招的offer拿到的全是北京的公司。在面试时很多面试官都会问我为什么要来北京？和同学说我打算去北京，他们也会问为什么要去那么远呢？北京空气质量不好，气候干燥，交通还拥堵。这些都是我真真实实要面对的问题，</p><p>但是我还是没有打算去其他城市，我觉得北京对于我有一种莫名的吸引力，或许是他深厚的文化底蕴，或许是他领先的经济发展水平，或者是他各类的活跃人才，这些也许其他城市也有，但总不能和北京比肩。在北京工作的经历会是一段富有意义的经历，这样的经历，越早越好。</p><p>近来也会思考人生的意义，以前觉得人生应该最求快乐，怎样快乐就怎样去度过一生，但是现在不这么觉得了，人生应该是追求充实，同样要去接纳苦难和波澜不惊，应该去领略各式各样的人生，如果总是快乐的，不免显得太单调无味。</p><p>距离今年春节已经不足三个月了，发现手里的事情还蛮多的，而且都有难度，毕业设计已经提上日程，目前还没有方向，想要在春招转后端开发，但是要学的东西还有很多，在快手的实习工作量应该会很足，也担心一些工作可能做不好，嗯，是的，不会说做完什么事就没事了，事情永远一件接一件，那，干就完了。</p>]]></content>
      
      
      <categories>
          
          <category> 人生履历 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>上海外滩之夜</title>
      <link href="/2020/04/26/%E6%B5%B7%E5%A4%96%E6%BB%A9%E4%B9%8B%E5%A4%9C/"/>
      <url>/2020/04/26/%E6%B5%B7%E5%A4%96%E6%BB%A9%E4%B9%8B%E5%A4%9C/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>来上海一周了，一切都好，因为自己前端基础比较薄弱，每天在公司会学很多东西，感觉很充实，很有成就感，但是每当晚上八九点独自一人回到住处，强烈的孤独感就会袭来，是一种让人心慌，不知所措的感觉。</p><p>昨天是星期六，来这里以后的第一个休息日，但是对这里都不熟，也不知道去哪里，只好一觉睡到十点。下午复习了一下课程，决定晚上出去走走，否则漫漫长夜实在难挨。东方明珠是小学课本里出现的，也一直作为上海的标志和上海联系在一起，出了地铁就看到了，但真的略感失落，因为她好像不是想象中的那么高大，尤其是在和周围那么多金融大厦相比。</p><p>走在黄埔江边，和王金梅聊了一路，感觉就没那么孤独了，孤独应该是要倾诉的吧。现在可以好好聊聊真心话的朋友真的越来越少了，不知为何，只能接受。天南地北聊了很久，我都忘记自己已经走了多远了。在意识到应该回去了才发现距离地铁站已经很远了，狠心想打车回去，奈何手机还没等到车来就没电关机了。立刻意识到情况不妙，地铁停运，手机没电，可能回不去了，只能趁现在江边还有人赶紧返回东方明珠附近，那里应该相对安全，一路快走，脚掌也不疼了，本来刚才散步就有点疼了。</p><p>已经十一点半了才走回到东方明珠塔下，幸好有一个保安亭可以充电，本来想央求他收容一晚上的，无奈他太不近人情了。一点钟充电差不多了，也不打算再去找住处了，现在到处跑也不安全，就在保安亭旁边角落做一晚上吧，和保安在一起应该更安全一点。从五个小时，一万八千秒倒数，晚上是真的有点冷，最冷的时候应该是凌晨四点钟的时候。先是坐地板上，发现地板太僵了，然后站着，站不动就蹲着，期待着黎明的到来。凌晨三点钟看到一个中年男人来翻垃圾桶，生活是有多难呢？凌晨四点钟就有人起床锻炼了，真的佩服；偶然听到那个保安和朋友聊天，他拒绝去工厂，太累了，还是当保安轻松，我就在想难道你可以做一辈子保安吗？凌晨四点钟就鸟儿就开始出来觅食了，叽叽喳喳的好多，我还以为城市没有鸟呢。</p><p>熬到五点，已经是黎明了，还好回去睡两个小时还赶得上上班。</p>]]></content>
      
      
      <categories>
          
          <category> 人生履历 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在美团点评的第一天</title>
      <link href="/2020/04/20/%E5%9C%A8%E7%BE%8E%E5%9B%A2%E7%82%B9%E8%AF%84%E7%9A%84%E7%AC%AC%E4%B8%80%E5%A4%A9/"/>
      <url>/2020/04/20/%E5%9C%A8%E7%BE%8E%E5%9B%A2%E7%82%B9%E8%AF%84%E7%9A%84%E7%AC%AC%E4%B8%80%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<p>今天是入职美团点评开始实习的第一天，是来到上海的第三天。在第一天晚上住的那个酒店里放了一个体重称，称了一下体重，133斤，果然，这三个月假期肥了7斤，比大学两年半肥的还要多。对于我来说，没有学习和工作的氛围，自律的学习和生活就不可能。</p><p>赶紧滚出舒适圈，今年行情不好，还是早些谋划出路。当混子的时间长了，连方向都分不清，先把三明北的高铁票买成了三明站，幸好没耽误下一程，然后把自己工作的地点弄错，之前联系要租的房子前功尽弃，在找房子的前一天晚上十二点还临时上网找房子，又把酒店定在了和公司截然相反的方向，行李箱都在漫长的换乘地铁的过程中拉坏掉，真的是路遥马亡。</p><p>今天入职，真正的开始把知识运用到工程。在办理入职手续的时候见到了很多也是今天入职的同龄人，感觉挺好的，年轻人比较多。HR联系徐斌学长接到了我，然后见到了部门leader，就是二轮面试的面试官，还记得当时聊了一个多小时，虽然很多问题我都答不出来，他也会给我解答一下，真人比视频上年轻是真的。部门工位满了，只能到隔壁部门借坐两天，这也挺好，和他们在一起自己那些low比操作怕是要被笑死。mentor是个应该毕业一两年的女生，虽然年纪轻轻，但是项目构思、技术表达都非常严谨和清晰，在今天晚上的小组周会上可见一斑。</p><p>八点下班走人，住得近真的好，可以步行上下班，早晚高峰挤地铁的事情我是不用体验了。回来接到了爸爸的电话，多是些叮嘱我这个涉世未深的小孩应该如何处理职场的人情世故。还记得在家面试的时候，每次面试妈妈都会问这家公司是哪里的，其实说了在哪个城市她也不知道，也还是要问问，应该是希望工作得城市不要太远吧。</p><p>要开始接收新任务了，还是赶紧学习，在被认出是菜鸡之前变得稍微强一点。</p>]]></content>
      
      
      <categories>
          
          <category> 人生履历 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对每一个不曾到达的地方，都要心怀向往</title>
      <link href="/2020/04/09/%E5%AF%B9%E6%AF%8F%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%9B%BE%E5%88%B0%E8%BE%BE%E7%9A%84%E5%9C%B0%E6%96%B9%EF%BC%8C%E9%83%BD%E8%A6%81%E5%BF%83%E6%80%80%E5%90%91%E5%BE%80/"/>
      <url>/2020/04/09/%E5%AF%B9%E6%AF%8F%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%9B%BE%E5%88%B0%E8%BE%BE%E7%9A%84%E5%9C%B0%E6%96%B9%EF%BC%8C%E9%83%BD%E8%A6%81%E5%BF%83%E6%80%80%E5%90%91%E5%BE%80/</url>
      
        <content type="html"><![CDATA[<p>放假已经快三个月了，因为疫情，才可以和爸妈在一起那么久，过完年就开始复习找实习，也准备了快三个月了，真的非常幸运，拿到了美团点评的Android工程师实习offer，否则我现在真的会焦虑死吧。</p><p>年后就在想，实习应该找什么岗位呢，自己大学学习的那些课程好像不足以应对工作，好像做什么都要从零开始，最终决定选择Android开发，是因为算法岗自己肯定不行，后台开发竞争太大了，前端庞杂难以短时间掌握，iOS开发目前没有硬件练习，测试门槛太低了，就只有Android是最优解了。整个准备的过程需要复习和学习的东西还是蛮多的，计算机网络、操作系统、数据库、Java、Android、JVM、设计模式等都要去学习，还要时常刷一点算法题。整个过程有一种山重水复疑无路，柳暗花明又一村的感觉。</p><p>3月10左右开始投简历，都忘记投了多少家公司了，每天都会去看一下简历状态，等待面试真的是很难受的一个过程。一开始面试的是蘑菇街，第一轮面试就挂掉了，然后小米、盛趣游戏、字节跳动、腾讯、CVTE等相继挂掉，虽然每一轮面试都入真准备，但是小厂需要可以直接干活的，大厂需要学习能力各方面都很优秀的，那我真的就没有去处了。</p><p>我一直感觉我是一个很幸运的人，特别是在一些人生的关键节点，都会遇到贵人相助，这次也不例外。美团点评也算大厂了，在美团点评面试之前就有一位美团点评iOS工程师打电话给我，希望我转iOS，让我好好准备笔试，这给我很好的心理暗示，然后面试的时候是一位女生面试官，人很友好，问的问题很简单，问题答不对也会引导，40分钟就结束面试了，当天就收到了第二次面试和第三次面试的邀请，这又给我了很好的心理暗示，难道默认第二轮面试通过吗？我想得太美了，第二轮是一个leader，一个多小时的面试都是基础知识轰炸，虽然很大都没有答出来，但是他还是给我过了。第三轮面试相对就比较轻松了，面试官人很好，天南地北的都聊。第二天就收到了offer call，下周一就收到了offer通知，曾为此不遗余力的复习，也曾辗转反侧的煎熬等待，终于所得届时所想，心中喜悦之情，难以言表。</p><p>在最近几次面试中，反复被问到了了对职业生涯有什么规划，没有想过的问题，自然回答得一团糟，但这个问题不可以回避，也无法回避，真的需要规划自己得职业生涯了，那种庸庸碌碌的校园生活所剩无几了。</p>]]></content>
      
      
      <categories>
          
          <category> 实践心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 成长 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>想要问问你，生活可如意</title>
      <link href="/2019/12/28/hello2020/"/>
      <url>/2019/12/28/hello2020/</url>
      
        <content type="html"><![CDATA[<p>在过3天就是2020年了，又一个十年的伊始。</p><p>回想过去十年应该是很惬意的十年，小学到初中在到高中，还有不紧不慢的大一大二两年，都过得潇洒恣意，也取得些许成就，至少无愧于自己也无愧于亲友。</p><p>现在的我说话已经时常用成年人打头了，成年人不能畏畏缩缩没有担当、成年人不能理所当然的继续成为家里的负担、成年人不能一事无成。</p><p>越是经常这样想就越是觉得失落。今年一心想着修学分，选课选得多了一些，再加上自己的资质是在过于平庸，一个学期下来整天围着作业打转，上半学期还好，还能勉强跟上，下半学期尤其是接近期末这段时间，只能是糊弄作业了，为此时常觉得难受。这种感觉在和同学们的对比总尤为强烈，自己进步得实在是太慢了，再仔细想想，自己有进步吗？</p><p>暂时先麻木吧，心为形役，挨过这个学期再说。</p><p>今年的下半年开始，考研和实习应该是思考得最为频繁得两件事。考研有风险，而且对经济独立有一种向往，所以时常在想着怎么开始第一份实习；感觉自己基础还不够扎实，尚不能胜任技术含量高得工作，而且担心本科学历会成为职业生涯的瓶颈。就是一个选择题，想了一个学期也没想明白，后来就决定先实习吧，一些主意光想就如同空中楼阁，不切实际，不如职场走一圈，去体会一下本科就业是否适合自己，就这样，路是走出来的，不是想出来的，适合什么亲自体验一番就知道了。</p><p>苒苒时光，当然不乏感动与快乐。</p><p>前两天哥哥在家人群里告知今年可能赶不上年夜饭了，让我们不要等他吃饭了，我先是厌恶它们公司放假晚而后只是无可奈何，爸爸看到消息以后说了一句“不怕伐个车去高铁站接你”，而后又说“我去高铁站联系车等你”，心里是感动的感觉，父母在的地方都是家，什么都不用怕。</p><p>每个人都开始忙碌各自的事，疏远的人越来越多，能够时常问候的人越来越少。和王金梅相识快十年了，感情依旧，幸甚。</p><p>今年课外文学阅读21本，还好阅读这个习惯没有被荒废掉。《霍乱时期的爱情》这本书使我最为震撼，贯穿一生的爱情，读来让人唏嘘。</p><p>一直想学口琴的，买了一把很贵的口琴却束之高阁，三分钟热度要不得。</p><p>今年有幸出境德国游学一次，有什么收获也说不上来，对自己的影响却是有的，时常想起自己说过好好学习，积极生活，山河俊秀，不可辜负。这个世界那么美，那么多原子聚合成一个现在的我在这宇宙千万年里就那么一次，真应该珍惜短短剑，去走遍山川湖海。</p><p>对下一个十年没什么规划，继续努力吧。</p><p>2020，对我好一点。</p>]]></content>
      
      
      <categories>
          
          <category> 生活随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>真爱之上，勿问时光</title>
      <link href="/2019/11/16/%E7%9C%9F%E7%88%B1%E4%B9%8B%E4%B8%8A%EF%BC%8C%E5%8B%BF%E9%97%AE%E6%97%B6%E5%85%89/"/>
      <url>/2019/11/16/%E7%9C%9F%E7%88%B1%E4%B9%8B%E4%B8%8A%EF%BC%8C%E5%8B%BF%E9%97%AE%E6%97%B6%E5%85%89/</url>
      
        <content type="html"><![CDATA[<p>船长看了看费尔明娜·达萨，在她睫毛上看到初霜的闪光。然后，他又看了看弗洛伦蒂诺·阿里萨，看到的是他那不可战胜的决心和勇敢无畏的爱。这份迟来的顿悟吓了他一跳，原来是生命，而非死亡，才是没有止境的。</p><p>“见鬼，那您认为我们这样来来回回的究竟走到什么时候呢？”他问。</p><p>在五十三年七个月零十天以来的日日夜夜，弗洛伦蒂诺·阿里萨一直都准备好了答案。</p><p>“一生一世。”他说。</p><p>断断续续读完《霍乱时期的爱情》已经快花了两个月的时间，看着书中弗洛伦蒂诺·阿里萨和费尔明娜·达萨从青年时期的青涩爱情中走失彼此，错过一生，再到生命的最后放下世俗成见，勇敢的走到一起，既唏嘘爱情的脆弱，也震撼于爱情的坚强。</p><p>年轻时的弗洛伦蒂诺·阿里萨曾独自一人坐在花园中的一条不易被发现的长椅上，在杏树的树荫下假装读一本诗集，直到看到那位可望不可及的姑娘走过。一念既起，执念终生。</p><p>弗洛伦蒂诺·阿里萨和费尔明娜·达萨也曾在情窦初开之时互相写信，通过文字悄无声息的传递着对彼此的思念和情意。</p><p>费尔明娜·达萨的父亲希望她的女儿通过一桩美满的婚事获得新生，两个年轻人脆弱且卑微，没有站在一起对抗世俗的风雨，一个短暂的远走他乡，一个被迫与父亲远游历练，在安排之下嫁给了声名显赫的医生。</p><p>弗洛伦蒂诺·阿里萨没有放下执念，跳出时光洪流，开始一生的等待。虽然费尔明娜·达萨已为人妻，在在柴米油盐中经历着所有人都会经历的酸甜苦辣、争吵和欢笑，但是弗洛伦蒂诺·阿里萨安心的修缮好房子就，并且决心一生独身，他自然的等待，等待费尔明娜·达萨的丈夫死去，再让他有机会得到她的爱。他的心是觉得忠诚的，虽然身体曾经无数次出轨。</p><p>长达五十一年等待后费尔明娜·达萨的丈夫意外死亡，弗洛伦蒂诺·阿里萨第一时间开始了对她的最求，回忆瞬间涌来，仿佛五十余年的时光不曾流逝。这一次，费尔明娜·达萨已经不再惧怕世俗压力，她说：“一个世纪以前，人们毁掉了我和这个可怜男人的生活，因为我们太年轻；现在又想在我们身上故技重施，因为我们太老了，让他们见鬼去吧，如果说我们这些寡妇有什么优势的话，那就是再也没有人可以对我们发号施令了。”</p><p>两个人在船上度过了最快乐的时光，也许是最后的时光。</p><p>读这本书的过程中多次想起一句歌词：假如我年少有为不自卑，懂得什么是珍贵；假如我年少有为知进退，才不会让你替我受罪。经常会看到很多人遗憾在最想照顾一个人的时候没有足够的勇气和能力，等到失去之后，虽然能力已经匹配，也有了抵抗流言的勇气，却也只能是一个人独自挣扎了，爱的人早就走散了，不甘心却也再也求不得。</p><p>这样的事情几千年了一直都有，别人的故事一直在听，自己却怎么也学不会的，真正要懂的道理，只有自己亲身经历并为之付出代价才能学会的，代价越惨重，领悟越深刻，这个时候道理记住与否多半不重要了，失去了就真的失去了，有些人有些事一辈子只能有一次。</p>]]></content>
      
      
      <categories>
          
          <category> 阅读随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十日游学，穿越德国</title>
      <link href="/2019/08/27/%E5%8D%81%E6%97%A5%E6%B8%B8%E5%AD%A6%EF%BC%8C%E7%A9%BF%E8%B6%8A%E5%BE%B7%E5%9B%BD/"/>
      <url>/2019/08/27/%E5%8D%81%E6%97%A5%E6%B8%B8%E5%AD%A6%EF%BC%8C%E7%A9%BF%E8%B6%8A%E5%BE%B7%E5%9B%BD/</url>
      
        <content type="html"><![CDATA[<p>day  1<br>经过十六个小时的飞行，今天早上十点到达德国汉堡。从起飞时俯瞰广州夜景的兴奋，到震惊于伊斯坦布尔的繁华，到身临其境的感受汉堡怡然自得的城市生活。汉堡给我的第一印象就是这里真是一座适合养老的城市，气候适宜，环境优美，生活节奏不慌不忙。街头两侧的房子都是精心设计的艺术品，红褐色的砖，凸起的房梁，朴素自然的装修，看起来美极了，真想为每一栋房子拍一张照片。<br>可口的中国餐，参观汉堡大学，夜晚结伴逛超市，真是美好的一天，我太困了，先睡觉了。</p><p>day 2<br>吃完早餐以后向汉诺威市进发，约一个小时来到了今天的第一站SLC，这是一家仓储公司，虽然先后进行了公司介绍，实地观摩，视频讲解等环节，我对这个公司在使用IT技术使得它不同于传统仓库的地方还是没有什么概念，当然不是吴导翻译的问题，只是我觉得并没有什么特别之处。<br>在观摩结束以后两点总结我觉得很有意义，第一，企业发展不可能是一本企划书就可以一蹴而就的，需要在不断的发展中不断试错，不断改进，第二，一个人对一件事不感兴趣也可以做得好，但是如果想把一件事做到极致，却缺兴趣不可，这让我我很焦虑，计算机科学发展得如火如荼，而我真的对它感兴趣吗？外加一点思考，企业发展不是单独依靠技术人才或者财务人才或者公关人才就能发展得好的，一个企业就是一个系统，决策者在领导企业前进的时候必须综合考量，不能违背经济学总资本追逐利这一基本原则。<br>中午了一些汉堡，薯条，可乐何水果沙拉，和妈妈打电话时国内已经八点了，真想带爸爸妈妈经历一下他们觉得很新奇的事。<br>三个小时来到市政厅，德国的高速公路真慢。给王金梅寄出了一张明信片，我好希望它能收到啊 。晚餐是一顿中餐，和张伟聊得挺好。入住酒店以后逛了商场，基本上都在八点钟关门了，德国人真悠闲。</p><p>day3</p><p>今天早上都在前往柏林的路上，下午达到柏林，在WISTA听取了他们关于高新技术园区产业孵化的介绍，认为大学，研究生，工厂三个要素是产业发展的必要条件，由于有些困倦，没有记住其他要点。<br>在乘车去吃饭的路上，遇见路边有一些其他国家的难民在公路边上给人家洗车，虽然一些司机拒绝给小费或者在他们的坚持索要下才勉强给了很少的小费，但是他们的脸上仍然洋溢着乐观自信的笑容，这让我很感动。生活多舛，我们唯有乐观可以在苦难面前从容不惊。</p><p>day4<br>今天周六，是休闲的一天。先后游览了胜利柱、苏联攻占柏林纪念园、帝国大厦、五大部、总理府、勃兰登堡门、屠杀犹太人纪念园、柏林墙、洪堡大学、圣母大教堂、博物馆、马克思恩格斯纪念园。<br>在游览柏林墙的时候看到几个黑人在很惬意的享受周末，本来想拍他们，但他们不知为何非常紧张，就此作罢。<br>午餐的时候和学院副书记闲聊追求时尚，他的观点认为受过教育的人应该形成自己的品味，不能被潮流引领，否则会沦为欲望的奴隶，我很认同。<br>八点回到酒店，倒下就睡着了，凌晨十二点才醒过来。</p><p>day4<br>今天周六，是休闲的一天。先后游览了胜利柱、苏联攻占柏林纪念园、帝国大厦、五大部、总理府、勃兰登堡门、屠杀犹太人纪念园、柏林墙、洪堡大学、圣母大教堂、博物馆、马克思恩格斯纪念园。<br>在游览柏林墙的时候看到几个黑人在很惬意的享受周末，本来想拍他们，但他们不知为何非常紧张，就此作罢。<br>午餐的时候和学院副书记闲聊追求时尚，他的观点认为受过教育的人应该形成自己的品味，不能被潮流引领，否则会沦为欲望的奴隶，我很认同。<br>八点回到酒店，倒下就睡着了，凌晨十二点才醒过来。</p><p>day 5<br>今天是星期天，仍然是德国人休息的一天，。早餐以后乘车前往莱比锡，中午到达，莱比锡在历史上属于东德，东德是社会主义阵营的一部分，也可以看出来相比于资本主义阵营西德的贫穷落后。午餐完毕前往德国民族大会战纪念碑，四周景色尽收眼底。继续参观德国公墓和中央火车站，大概了解了德国的丧葬文化，对德国人热衷植树还是很佩服的，这历史久远的火车站不像火车站，里面各种商铺尽管是星期天也正在营业。逗留太长时间，没有时间参观莱比锡大学和市政厅了。</p><p>day 6<br>今天可以说一天都是在车上度过的。八点出发前往美因茨，高速公路两旁的景物已经渐渐由平原变成森林，阳哥撒在松树上的暖色让人很享受。下午三点到达美因茨大学，听了教授关于德国数字化的讲座，有幸得到一个提问机会，我问教授为什么移动支付如此方便但是德国却不使用，他的回答说银行资本家拒绝使用，这也许就是资本主义的弊端，阻碍生产力进步。讲座结束继续乘车前往美因河畔法兰克福。</p><p>day 7<br>今天从法兰克福前往斯图加特参观凯驰生产线，高速公路两旁开始出现出现山峦，平缓的山坡上星罗棋布的种了一些苹果树，大巴行驶几分钟便会出现静谧的欧洲小镇。早上十点抵达。讲座和生产线观摩，给我印象最深的就是德国中小型企业对独特品牌的执着追求，对质量的严格把关，他们始终坚持做一种产品，并把这个产品做成全行业第一。<br>中午开始下起蒙蒙细雨，来到一个奢侈品大卖场，只不过囊中羞涩，什么都没买。</p><p>day 8<br>今天一早便开车去海德堡，沿着内卡河行驶一会儿下车，跟着吴导走在欧式风格的小镇上，遥望海德堡城堡，探访海德堡大学，真是一件惬意的事情。独自爬山来到哲学家小路，据说这是康德等哲学家曾经走过的小路，这条小路上人很多，但是大家都很惬意的在散步，不慌不忙。遥望远处，红色砖瓦的欧式风格小屋连成一片，绵延到远方。下山的时候一个中国女孩请我给她拍照，我很开心，因为听到中文真的不容易。<br>午餐结束以后乘车返回斯图加特参观梅赛德斯奔驰博物馆，偶遇一个女孩，不知姓名不知国籍，就是觉得她好美，全程无心观车，要么尾随其后，要么站在她会经过的地方带她经过，可以想象喜欢一个人会有多么卑微。</p><p>day 9<br>早上从斯图加特前往辛德芬根参观梅赛德斯奔驰生产线，第一条生产线全是机械手在流水线上加工汽车，这让人很震撼，机械化程度如此之高的工厂，德国不愧是一个工业强国，中国相比之下还差得很远。第二条生产线是定制化生产线，个人都在流水线上各司其职，但是生产效率也同样很高，一天可以完成170台左右。<br>乘车前往慕尼黑的路上，猪排和炸土豆作为简单的午餐，下午四点到达慕尼黑，两个小时的购物时间，强哥，家源和我还是一样都没有买，我手机没电独自去找洗手间，资本主义太可怕了，地铁站里的洗手间都要收费，无奈没带钱，只能忍着了。闲逛之余，看到街头忘我的弹钢琴的男子，夕阳撒在教堂的余晖，一切都那么赏心悦目，很开心一个中国同胞和我打招呼。<br>今天晚上的晚餐比较特别，到德国皇家啤酒屋就餐，9欧元的半杯啤酒喝得我心痛，这里挤满了人，大家啤酒和猪脚吃得很开心，加上愉快的音乐，真是一个美好的晚上。</p><p>day 10<br>今天是在德国的最后一天，原定计划参访慕尼黑工业大学，与留学生联谊的活动莫名其妙就没有了，早上起来直接前往市中心自由活动，我选择临走之前给家人买一点礼物。<br>逛了许久给弟弟买了一块手表，给爸爸买了一个钱包，由于时间不够，也是不了解妈妈和哥哥的喜好，没有给他们买，很遗憾。两件礼物折算人民币挺贵的，但是难得来一次，就狠心买了，以后努力挣钱吧。<br>六点半起飞，九点抵达土耳其的伊斯坦布尔，本来凌晨一点的飞机居然延误到五点，太难了。</p>]]></content>
      
      
      <categories>
          
          <category> 人生履历 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 旅行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再见，盘联，年岁中最灿烂的一段时光</title>
      <link href="/2019/08/06/%E5%86%8D%E8%A7%81%EF%BC%8C%E7%9B%98%E8%81%94%EF%BC%8C%E5%B9%B4%E5%B2%81%E4%B8%AD%E6%9C%80%E7%81%BF%E7%83%82%E7%9A%84%E4%B8%80%E6%AE%B5%E6%97%B6%E5%85%89/"/>
      <url>/2019/08/06/%E5%86%8D%E8%A7%81%EF%BC%8C%E7%9B%98%E8%81%94%EF%BC%8C%E5%B9%B4%E5%B2%81%E4%B8%AD%E6%9C%80%E7%81%BF%E7%83%82%E7%9A%84%E4%B8%80%E6%AE%B5%E6%97%B6%E5%85%89/</url>
      
        <content type="html"><![CDATA[<p>2019年寒假，还在火车上就已经一直看着窗外的风景，裸露的山丘和成片的油菜花不断消失在身后，火车不断前进，我的心却好像比火车还要快，早已经到达盘联寒假工作的集合地点——盘州市职业技术学校。下午五点左右火车终于抵达，盘州冬日的暖阳配上短袖刚刚好，急忙叫了一个摩的就直接到职校报到。来到职校见到了以前的老友，当然也有新人。</p><p>这个假期我同时负责企业观摩会、全国分会、媒体中心。想想已经是在盘联的第三个假期了，比自己老的人已经没几个了，自己真的做好准备去做一个独立的负责人了吗？好像没有，自己并没有成熟多少。</p><p>小汪老大，阿绿和我，我们三个搭档负责媒体中心一直让我充满信心，小汪细心可靠，阿绿技术过硬，在校期间一起沟通媒体中心日常工作、周末专栏约稿、组织招新、宣传盘联等等，三小只这个群成为使用频率最高的群这一，和你们一起商量做事真好。</p><p>今年媒体中心又注入了新鲜的血液，刚哥、亚南、章金、永浩、明丽、红霞。在校还没见面时就约定面基的时候谁如果认不出对方就请吃洋芋吧，虽然开过视频，但是还是出现没有认出来的情况。小汪一开始没认出刚哥，我也没认出一直跟在小汪后面的亚南。媒体中心是一个大家庭，拍一张全家福实在不容易，在办完企业人才沙龙以后，大家一起到东湖拍合照，已经是日落了，等大家聚齐拍完合照感觉天瞬间就黑了。</p><p>绝大多数的盘联记忆都来自于媒体中心，一起围坐桌前编辑推松、排版杂志，一起配置路由器、一起吃饭、一起翻铁门吃早餐、一起踏着夜色高唱《放飞》走回宿舍……</p><p>拍完合照以后新老成员聚餐，结束以后想去KTV唱歌，但是今天企业人才沙龙的推松好像还没有排，小汪老大，刚哥和我就近找了一家网吧去做推松。小汪老大一看就是惯犯，心平气和走完全程，我就比较垃圾了，参会名单没有，推松也做不成。</p><p>唱完个大家也还不甘心就散掉，那就再去吃烧烤吧，吃烧烤当然不可能就只吃烧烤，那么多人得吃多少钱呀？喝酒才是真的。曦姐，沙沙和我一起提了两件啤酒，配上烧烤，烟火味十足得开始划拳喝酒。酒过三寻，还剩几瓶没喝完，职校是回不去了，那就鑫盛宾馆开一个套间回去继续喝。小汪阿绿状态都还好，其他要么醉意朦胧要么睡意朦胧。这个时候都是最无顾及得状态，和小汪直接拿起瓶子干的样子真是痛快。渐渐大家都睡去，第二天当然是难受的一天，但我好像神清气爽的过了情人节。媒体中心彻夜长谈还有一次，文艺汇演结束当晚，沙沙和娜姐在宿舍等我们，尽管我们排完推松回到宿舍已经很晚了，她们还是等着。天南海北忘记说了些什么，但年轻人在一起谈的感情问题通常不会缺席，媒体中心如何继续发展也讨论了好久。</p><p>这个寒假盘联已经走过14年的风雨了，从最初的“前程”演讲会，到今天制度齐全发展成熟的盘州市大学生联谊会，很多人在这里投入了很多心力也收获了成长，很幸运，我是其中的一位。在一起为盘联庆祝生日的时候真的很感动，一起高唱会歌，一起吃一块蛋糕，一起说出对盘联的祝福，一起陪盘联继续走下去。</p><p>这个假期我把主要精力都投入到了企业观摩会这个活动中，从负责人选举时的一时兴起，到彻底结束这个活动竟前好将近花费了近一年的时间。从反复修改策划，到开始联系企业，经历了在一家公司门口无聊的等待、经历了在出发产研中心之前还没有车的恐慌、经历了被企业对接的工作人员忽视的难受、经历了昆明城区限高导致活动延期的急躁、经历了八点从红果打车回家被司机带到丹霞的荒诞、经历了4000块车费迟迟不到账的烦恼……</p><p>对于全国分会，我的工作始终是不到位，因为我最初就不知道什么是全国分会，然后到后来的觉得全国分会没有多少实际意义，每次思考该怎么去改进它的时候，最好的思考结果都是再问自己全国分会现在真的还有意义吗？鹏哥和丹卿姐在上面投入了许多精力，翱翔和我在迷茫中接过担子，发现有点被动的去做一件事，分会活动越来越少，一些分会甚至成员都补齐，应付着主席团下达的任务，对于这些情况，感觉有点无力。</p><p>第七次会员代表大会选举出了新一届会长团，那天情绪有些低落，我想大概来自于新旧交替的自信心缺乏和出乎意料的选举结果。小汪当天回家，部门好像没剩下几个人在位了，加重了这种情绪。</p><p>在学校协助完成了职中杂志的排版，现在算是从盘联的工作中抽身出来了吧，但还是很关注朋友们在盘联工作的新闻，有时真的很向往那种在一起做事的快乐。</p><p>再见，盘联，年岁中最灿烂的一段时光。</p>]]></content>
      
      
      <categories>
          
          <category> 人生履历 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 盘联 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>盘联时光，渐入佳境</title>
      <link href="/2019/07/31/%E7%9B%98%E8%81%94%E6%97%B6%E5%85%89%EF%BC%8C%E6%B8%90%E5%85%A5%E4%BD%B3%E5%A2%83/"/>
      <url>/2019/07/31/%E7%9B%98%E8%81%94%E6%97%B6%E5%85%89%EF%BC%8C%E6%B8%90%E5%85%A5%E4%BD%B3%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<p>还记得在刚刚面试加入媒体中心的时候我曾问娜姐，盘联的小伙伴之间关系真的那么好吗？他很确定的告诉我是的。2018年暑假回家，迫不及待的想再见到那群上个寒假在一起工作的人。刚刚下火车，就先赶到鑫盛宾馆，但由于还要回家，只在楼下见了敖倩和杨佐。</p><p>这个暑假娜姐实习没有回来，是沙沙主要负责媒体中心。大家集结都比较快，阿绿，小汪，菜玲，丹丹，小甘，沙沙，敖倩，杨佐，阿曦，翱翔，还有我，都迅速在在鑫盛宾馆五楼的一个小房间里集合。小甘到位那一天中午正好是老成员丽平姐和陈曦来请吃饭，很多人都是初次见面，却真的感觉就像早就认识了一样。</p><p>办公场地比较紧张，和宣传部挤在一个套间里面，里面就是三间客房一个卫生间一个洗漱间，而我们整个部门就围绕在一张茶几周围，插座和桌面的利用率接近百分之八十。七八个人围坐在这里，阿绿踏踏实实的完成了表情包设计，丹丹在新闻稿上独当一面，倩倩、翱翔、阿曦紧锣密鼓的筹备盘联直播，小甘直接上手剪辑视频，杨佐时常提出很多建设性意见，菜玲和小汪杂志排版全面推荐，沙沙统筹全局，有条不紊，我，十多天一个百度百科也没修改好。媒体中心经常熬夜这是真的，我总感觉就是才上班一会儿怎么就又要下班了。两次熬夜记忆深刻，一次是工作到很晚了，大家开始谈心，睡衣全无，都互相指出最近存在的问题和小伙伴们需要改进的地方，凌晨三点才睡；另一次是校对汇报杂志《盘联之声》，一字一句，标点符号也不容出错，后来再看其他媒体的推松或者文章，总是偶尔去纠一下别人的排版或者句子的错误，我很确定，这是再媒体中心呆久了落下的病根。</p><p>在一起做喜欢的事情是一件很开心的事，然而我们这群俗人当然也想着安排一下，因为在红果大城花天酒地是一件很美滋滋的事呀。总是想着哪天安排一顿烤鱼，哪天去KTV嗨一晚，哪天去吃一顿烧烤。我很抱歉呀，一开始答应翱翔和阿绿我要安排一次烤鱼的，结果食言了，但是难忘的事情总是出于意外，下班以后不甘心就这样睡去，对后勤安全部含糊其辞的报备以后，走上弥漫啤酒与烤串味的红果街头，想着在哪家小店一醉方休。最后来到只放了桌子板凳的一家临时小店，点上啤酒烤串，当然都不会落下真心话大冒险之类的游戏。</p><p>吃喝玩乐的时光总不会少，联谊会全体小伙伴在东湖边上的联谊很有趣，虽然很多人是初次见面，很多人平时很内向，但大家也都放开了玩。至于我们部门，总是喜欢烧烤店和KTV这种喧闹的地方，大声打牌、大声（跑调）唱歌总是让人很放松。</p><p>我很多次都潜意识的认为我们部门是盘联最优秀的部门，我想这种错觉来源于我们都很团结。在每一场活动到来之前，只要需要我们，拍照、写稿、推送制作、音频视频设备控制总是各就各位，有条不紊，比如吃盒饭也有爱的围在一起。</p><p>又是一个躁动不安的晚上，大家又厮混到了红果街头，不过这次意见不是很统一，看电影不成，吃烤鱼时机不合适，当时又要下雨了，往回走的时候实在不甘心就这样回去，居然进了凯歌KTV打算唱歌，一问价格有点贵，悻悻离去，出来才觉得尴尬，太丢联谊会的人了吧，都快十二点了穿着联谊会的文化衫在街头游荡也就算了，在这个点了居然还打算一头钻进KTV。只有在KTV里面才知道谁是麦霸，我觉得翱翔都比不过阿绿。</p><p>联谊活动那天的游戏我觉得好像很一般，但是人多了玩起来就很有趣，背对背带气球？其他好像记不起来了叫什么了。六月的雨打断了活动，但是意外的美丽总是难忘，所以才会有接下来的在避雨的时候，悠闲的喝着刺梨王，合唱会歌《放飞》，我们的歌声在东湖公园回荡了很久，阴沉的天气也阻挡不了我们的欢快。</p><p>每天一起结伴去吃饭也是一件很开心的事，要走十分钟吧，不过那家饭店真的好小，菜也做得不怎么样，偶尔几次都是最后没菜只能吃米饭。经验证明，挤在一起吃饭可以助长胃口，所以总是感觉一直在加菜，渐渐的明白还是多吃米饭吧，文气一点。</p><p>住宿，就是回住处晚了的会没地方睡，一开始支教活动队员还没来报道还好，挤一挤还是睡得下去的，然而随着队员增多，问题来了，没地方睡。一次我回房间晚了，只能翻窗子去另一个房间睡沙发，其实有沙发也还算好，有一次连沙发也没了，阿绿拿一块沙发坐垫直接睡地上，他为人比较好，让我睡了沙发。</p><p>暑假活动要结束了，大学生论坛拍照、各种活动启动仪式、大小会议、企业人才沙龙、全国分会代表大会，都有在参与，却感觉没做什么，接下来也未多做考虑，接下协助市团委文化督察的任务，五天走访普古、羊场、鸡场坪、淤泥河、旧营、英武。真的多亏了徐康、徐赛、徐矿和许娟的全程陪伴，在这场渐渐枯燥的下乡活动中始终充满乐趣，爬过娘娘山，体验了一次一览众山小的感觉，也第一次在鸡场坪的酒店里尝试了红酒的滋味，第一次去小康家玩得那么开心。</p><p>在工作基本都结束以后，抱着游玩和帮助菜玲小甘完成剩余检查任务的心态，我和阿绿也来到了竹海。没走过多少竹海的路，但我觉得竹海景色真不怎么样。小甘做东，好好的接待了我们，我一时忘乎所以，喝了个酩酊大醉，吐得天昏地暗。工作热情已经耗尽，和阿绿、聂祥娇草草结束了老厂的检查，就赶回盘县了。</p><p>这是一个热情洋溢的暑假。</p>]]></content>
      
      
      <categories>
          
          <category> 人生履历 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 盘联 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对于盘联，情不知所起，一往而深</title>
      <link href="/2019/07/30/%E5%AF%B9%E4%BA%8E%E7%9B%98%E8%81%94%EF%BC%8C%E6%83%85%E4%B8%8D%E7%9F%A5%E6%89%80%E8%B5%B7%EF%BC%8C%E4%B8%80%E5%BE%80%E8%80%8C%E6%B7%B1/"/>
      <url>/2019/07/30/%E5%AF%B9%E4%BA%8E%E7%9B%98%E8%81%94%EF%BC%8C%E6%83%85%E4%B8%8D%E7%9F%A5%E6%89%80%E8%B5%B7%EF%BC%8C%E4%B8%80%E5%BE%80%E8%80%8C%E6%B7%B1/</url>
      
        <content type="html"><![CDATA[<p>现在是晚上十一点半了，终于将追忆盘联这件事付诸行动了。以前还在盘联负责一些工作的时候就有过这个想法了，想着等哪天我结束了在盘联的工作了，一定要花时间把这段让我全力以赴投入其中的经历记录下来，因为在这里遇见了那么多志同道合的、有趣的、朴实的伙伴，因为在这里从对学生组织的一无所知到独立组织活动，因为在这里我看到了自己的成长。</p><p>遇见盘联从参加还未成型的企业观摩会开始，刚刚考上大学就收到盘联邀请参加兴仁泛亚集团，见到了元元姐、波哥、丽萍姐。白天参加活动一天但是人都没记全，晚上泡温泉才嗨到一起。短暂的一天观摩活动结束，但是我们的缘分还要继续。</p><p>2017年10月，盘联招新，报名媒体中心。据娜姐们后来说，他们在讨论是否接收我的时候，他们争议很大。寒假集合，很忐忑的来到职校，迟到的我见到了第一个我在加入盘联后遇到的人，张彦飞。进入集合教室时原来他们在开见面会，不明情况的我赶紧走到一排坐下，林广和龙哥，汤坤贤唱歌的情景都还清晰。</p><p>寒假，天气比较冷。第一晚睡觉就成了问题，职校的床太短了，被子不但薄还短，睡觉一直时一件很困难的事，头几天都是睡到半夜被冷醒，实在受不了，拼床。管鸿盛，习权州和我，三个人睡两张床，挤在一起舒服多了。热水供应也是固定时间的，想洗头什么的请早起。有一天早上去吃早餐的一段上坡的沥青路结冰了，我们三个互相扶着也站不稳，只能走路边的水沟上去。那是晚上十点左右吧大家一起回宿舍，虽然冷但是大家在一起很开心呀，路边还有小伙伴互相打雪仗，在上一段台阶的时候，一个女生没站稳，左右摇摆了3秒吧，还是摔倒了，对不起我当时笑出了声。</p><p>说真的，在盘联的这个假期，在技能方面，我是真的是一块朽木，简单的PS，ID也是总学不会，问对面宣传部的龙哥问得太多了我都不好意思了，比如说，至今也没搞懂什么是蒙版。十多天在办公室我就排了几页ID？是这样吗？好像是。娜姐让我把我的作品发给姜鹤看一下，当时的我居然自信满满的说还可以，她们却觉得太中规中矩了，审美需要提高。工作的东西记不太多了，因为我感觉这个寒假我就是被保护的小朋友，媒体中心六个老成员我一个新成员，美滋滋的，工作完全没有压力。</p><p>一个地上堆了一层小雪的早晨，大家专门抽出时间拍合照。媒体中心和宣传部由于姻亲关系等原因，关系比较好，所以一起拍，撒雪拍照很浪漫呀，定格了很多美好的瞬间。</p><p>后来陈曦要走了，没有过多的不舍得，只是感觉那两天媒体中心好像突然散掉了，对的，就是这种感觉，因为大家都不怎么说话了，迟到早退也出现了。送陈曦离开是一个晚上，也是十点左右吧，本来只是娜姐和沙沙去送，后来我和廷哥也跟了下来。世间难忘的事多半是因为巧合，比如这一次五个人的彻夜畅谈。走到大桥上俯瞰红果城，瞬间脚步轻快了许多，所以一下子就从干沟桥游逛到了红果街头，也许也是因为和三五好友畅谈惬意的缘故。还不想散，那就干脆在鑫盛开一个套间不回宿舍了吧，扎完气球又在去卖烧烤回来吃，聊天到什么时候也忘记了。</p><p>喝酒的时光最让人难忘，即便当时连路都走不稳了，过后却记得明明白白。寒假工作结束，大家回家之前本来小聚一次，但不知道怎么就聚到烧烤店里面去了，朱怡，龙哥，陈曦，娜姐（不胜酒力），沙沙（撂倒一桌猛汉），张昭海喝了几场以后，沙沙又叫来几个朋友，继续下半场，跑洗手间越发勤快了。记得当时江小白酒瓶上写了一句话——青春不是一段时光，而是一群人。</p><p>二分之一财务部的蝶姐，头顶戴一口锅的花儿，很搞笑的三瓢，很多未及深交的小伙伴，明年暑假见。</p>]]></content>
      
      
      <categories>
          
          <category> 人生履历 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 盘联 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/07/29/hello-world/"/>
      <url>/2019/07/29/hello-world/</url>
      
        <content type="html"><![CDATA[<br><p>花了两天的时间，终于把博客搭好了，以后要多写东西呀。</p>]]></content>
      
      
      <categories>
          
          <category> 实践心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写在五月初五</title>
      <link href="/2019/07/28/%E5%86%99%E5%9C%A8%E4%BA%94%E6%9C%88%E5%88%9D%E4%BA%94/"/>
      <url>/2019/07/28/%E5%86%99%E5%9C%A8%E4%BA%94%E6%9C%88%E5%88%9D%E4%BA%94/</url>
      
        <content type="html"><![CDATA[<p>在2019年2月9日星期六写下这篇文章有点尴尬，要怎么样来定位它呢，算是对去年的总结吧，有一点晚了，如果说是今年的展望吧，也有一点晚了。那就把它写成对2018年的回忆吧。</p><p>年初继续参加了联谊会的年后工作，作为小朋友，感觉什么都没有做，也没有学到什么东西，就匆匆混过了年后十天。</p><p>大一的下半个学期仍然没有感觉到学业的压力，仍然坚持读万卷书行万里路的生活理想。</p><p>读完了林语堂的《苏东坡传》、路遥的《人生》、余秋雨的《行者无疆》、姚云的《坐到夕阳披挂下来》、阮义忠的《失落的优雅》、宿文渊的《人一生要注意的50个细节》、安武信吾的《会做饭的孩子走到哪里都能活下去》、阿科塞的非常病人：《病夫治国》续集、洪应明的《菜根谭》、中华人民共和国宪法、叶子的《北京没有海》、毛泽东的《矛盾论》和《实践论》、杨伯钧的《论语注释》、当年明月的《明朝那些事儿》前七部等。</p><p>去越秀区看了花灯，回来的路上即兴去了了天河区；历经挫折找到了向往已久的大夫山，却感觉风景一般；火炉山除了大也有没有什么特别的风景；华南农业大学还好，除了景色不错，还有独家的华农酸奶，这里也要感谢老同学刘萍的接待；某天下午参观了广州市图书馆和广东省博物馆，这一张图让我驻足许久；借作为志愿者的身份，免费玩了一次忘记叫什么的馆；在国庆节去了石室圣心大教堂，感受了一下基督文化，广州十三行博物馆让历史书上的东西再现眼前；沙面大街建筑独特，这应该是是带女朋友去的绝佳去处，一直想乘坐邮轮看一下夜色中的广州，那一晚也得偿所愿；华南植物院与中大有着很深的历史渊源，班级团日活动参观了这里；在元旦节，一次性玩了红专厂创意园、广州动物园等，第一次见到了很多动物；去深圳参观了华为总部，第一次让我清醒的知道为什么要到大公司就业。</p><p>上半学期虽然感觉自己很努力了，但是排名仍然不够理想，就好像忙碌是为了麻痹自己一样。3.008的绩点已经到了本专业的末尾了，直接导致选择专业方向时被调剂到了超级计算机方向。六月初，一个已经快被遗忘的女孩闯入我的世界。</p><p>很快又到了暑假，这暑假的几乎全部时光都是在盘联度过的。成为了媒体中心的副主任，但是什么都不会的自己什么都做不好，唯一的任务修复百度百科也没有完成。倒是在带队下乡验收创文工作时经历颇多，感悟颇多。</p><p>回到学校决定报名学车，由于课业繁重，考过科目一就没有时间练习剩下的科目了。</p><p>我是很矫情的，莫名其妙的回到了了一个人的状态。这样也适合我，有空了就去摸索学习建设网站、做小程序、做app，学Linux，但是什么都没有学好。叫上两个朋友，组了三剑客小队参加学校ACM新手赛，侥幸获奖；满腔热血的又带头组队参加中国大学生服务外包大赛，感觉什么都不会居然选择了题目“智慧教室学生状态检测系统“，不想放弃和无从下手的状态困扰我许久，最后只能选择放弃，愧对四位同学。公教楼，图书馆、食堂、宿舍，四点一线的度过了大二下学期。</p><p>寒假直接去了职校，这一次我扮演的角色是媒体中心副主任、企业观摩会负责人、PBC执行副主席。第一次组织企业观摩活动，带领22个人去了宏财集团参研中心和金彩盘州旅游集散中心，由于自己经验不足和一些客观原因，效果不理想；参与筹备PBC第四次全国代表大会，也出现许多纰漏；媒体中心寒假工作繁重，说起来就只有愧疚。</p>]]></content>
      
      
      <categories>
          
          <category> 生活随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心情 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
