<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="k子的小天地"><meta name="keywords" content=""><meta name="author" content="hohnor"><meta name="copyright" content="hohnor"><title>甜茶不贵</title><link rel="shortcut icon" href="/melody-favicon.png"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?6216f76ee0b952906ada65e98f09e4a1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '6.0.0'
} </script><meta name="generator" content="Hexo 6.0.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">hohnor</div><div class="author-info__description text-center">k子的小天地</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">26</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">12</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">6</span></a></div></div></div><nav id="nav" style="background-image: url(http://images.zhulk3.cn/blog/sky.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">甜茶不贵</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="site-info"><div id="site-title">甜茶不贵</div><div id="site-sub-title"></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2022/02/10/Executor%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8/">Executor框架的使用</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-02-10</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/">技术积累</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Java/">Java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91/">并发</a></span><div class="content"><meta name="referrer" content="no-referrer" />

<p>在Executor框架中，工作单元包括Runnable和Callable，执行机制由Executor框架提供。</p>
<h2 id="两层调度模型"><a href="#两层调度模型" class="headerlink" title="两层调度模型"></a>两层调度模型</h2><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b99fd61c3af04612a63ef8cc00292289~tplv-k3u1fbpfcp-watermark.image" alt="executor.png"></p>
<p>多线程程序将任务分解为多个任务，然后由用户级调度器Executor将这些任务交由Java线程执行。Java线程并不是直接被CPU调度执行，还会映射为操作系统内核线程，由内核调度器将内核线程调度到CPU执行。祥见<a target="_blank" rel="noopener" href="https://www.kancloud.cn/zhangchio/news/754628">Java线程和os线程</a></p>
<h2 id="Exectuor框架的结构"><a href="#Exectuor框架的结构" class="headerlink" title="Exectuor框架的结构"></a>Exectuor框架的结构</h2><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7dc4064f4fbd406698cb1d25657c3a42~tplv-k3u1fbpfcp-watermark.image" alt="worker.png"></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/249b3e055ce14c6897c9423fc3531b7a~tplv-k3u1fbpfcp-watermark.image" alt="manager.png"><br>Executor框架由三大部分组成：</p>
<ul>
<li>任务，包括被执行任务需要实现的接口，Runnable接口和Callable接口；</li>
<li>任务的执行，任务机制的和讯即接口及其实现类，ThreadPoolExecutor和ScheduledThreadPool;</li>
<li>异步计算的结果，Future及其实现类FutureTask；</li>
</ul>
<h3 id="Executor框架的使用"><a href="#Executor框架的使用" class="headerlink" title="Executor框架的使用"></a>Executor框架的使用</h3><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/111948a08b1a4519b063a97bc121047d~tplv-k3u1fbpfcp-watermark.image" alt="use.png"><br>主线程创建一个Runnable或者Callable任务（Executor可以将Runnable类型转换为Callable类型），然后交给Executor执行，主线程通过返回的Future接口，阻塞等待任务执行以后返回结果，也可以在等待过程中取消任务执行。</p>
<h3 id="Executor框架核心类"><a href="#Executor框架核心类" class="headerlink" title="Executor框架核心类"></a>Executor框架核心类</h3><ul>
<li>ThreadPoolExecutor，线程池的核心实现类，用来执行被提交的任务。通过工厂类Executors实现三种类型线程池：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//核心线程数和最大工作线程数量相等，避免创建大量线程，适用于服务器负载较重的情况。</span></span><br><span class="line"><span class="comment">//使用无界队列LinkedBlockingQueue作为任务管理队列，意味着线程池中工作线程不会超过核心线程。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//没有核心线程，最大工作线程取整数的最大值，适用于有比较多短期的小任务场景；</span></span><br><span class="line"><span class="comment">//使用SynchronousQueue作为工作队列，当主线程提交任务速度大于线程处理速度时，会不断创建线程，有可能会因为创建过多线程导致CPU和内存耗尽</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只会创建一个工作线程，适用于需要保证顺序的执行各个任务的场景。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ScheduledThreadPoolExecutor用于在固定延迟后执行任务，通过Executors创建，包括两种类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只会创建单个核心线程，工作线程为Integer.MAX_VALUE</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DelegatedScheduledExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>, threadFactory));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以设置多个核心线程,工作线程为Integer.MAX_VALUE</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Runnable接口和Callable接口的实现类，都可以交个线程池执行，不同的是Callable接口可以返回结果.也可以将一个Runnable对象封装为Callable对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">callable</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RunnableAdapter&lt;T&gt;(task, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用DelayWorkerQueue作为工作队列，这是一个无界阻塞队列，使用PriorityQueue实现。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue(), threadFactory, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d0498dc7cd647109a4b33eb05b8c507~tplv-k3u1fbpfcp-watermark.image" alt="schedule.png"><br>主线程向DelayWorkerQueue中添加任务时，任务会被包装为ScheduledFutureTask，线程池中的线程会从队列中取出任务执行。</p>
<h3 id="ScheduledThreadPoolExecutor的实现"><a href="#ScheduledThreadPoolExecutor的实现" class="headerlink" title="ScheduledThreadPoolExecutor的实现"></a>ScheduledThreadPoolExecutor的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ScheduledFutureTask(Callable&lt;V&gt; callable, <span class="keyword">long</span> ns) &#123;</span><br><span class="line">    <span class="keyword">super</span>(callable);</span><br><span class="line">    <span class="keyword">this</span>.time = ns; <span class="comment">//表示这个任务将要被执行的具体时间</span></span><br><span class="line">    <span class="keyword">this</span>.period = <span class="number">0</span>; <span class="comment">//表示任务执行的间隔周期，</span></span><br><span class="line">    <span class="keyword">this</span>.sequenceNumber = sequencer.getAndIncrement(); <span class="comment">//被添加入任务队列的顺序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DelayQueue中的任务是ScheduledFutureTask类型，包括三个成员变量。DelayQueue封装了一个PriorityQueue，会根据ScheduledFutureTask的time和sqquenceNumber进行排序。线程池中的线程会从任务队列中取出time大于当前时间的任务进行执行。在执行结束以后，会更新time，重新将任务放回队列之中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setNextRunTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> p = period;</span><br><span class="line">    <span class="keyword">if</span> (p &gt; <span class="number">0</span>)</span><br><span class="line">        time += p;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        time = triggerTime(-p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p>由于FutureTask继承了Future接口和Runnable接口，所以可以把一个FutureTask接口交由实现了Executor的线程池执行，也可以作为计算结果返回,然后执行FutureTask.get()阻塞当前线程等待返回计算结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);</span><br></pre></td></tr></table></figure>
<p>FutureTask是基于AbstractQueuedSynchronizer（AQS）实现的，很多可阻塞类都是基于AQS实现的，AQS是一个原子框架，提供了通用机制来原子性的管理状态，阻塞和唤醒线程，以及维护被阻塞线程的队列。对于很多阻塞类，其具体操作都会委托给实现了AQS的内部类Sync，由Sync进行具体的操作。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53f063b85502467189b0decd26a66027~tplv-k3u1fbpfcp-watermark.image" alt="aqs.png"></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/02/10/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8/">线程池的使用</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-02-10</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/">技术积累</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Java/">Java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91/">并发</a></span><div class="content"><meta name="referrer" content="no-referrer" />

<h2 id="使用线程池的益处"><a href="#使用线程池的益处" class="headerlink" title="使用线程池的益处"></a>使用线程池的益处</h2><ul>
<li>避免重复创建线程执行任务，减少了创建线程和销毁线程需要的时间开销和性能开销；</li>
<li>提高任务响应速度，线程池中通常缓存有线程，当提交任务以后，可迅速执行；</li>
<li>避免了无规则的创建大量线程，导致大量线程排队等待CPU，响应速度变慢；</li>
</ul>
<h2 id="线程池处理流程"><a href="#线程池处理流程" class="headerlink" title="线程池处理流程"></a>线程池处理流程</h2><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/59976e0fd2fe42d9862b3db3be1aa4d1~tplv-k3u1fbpfcp-watermark.image" alt="stage.png"></p>
<p>我们可以调用线程池的execute和submit方法来提交任务，提交参数都是一个Runnable实例，不同的是，submit会返回一个Future类型的对象，可以通过future对象的get方法获得返回值，注意这个方法会阻塞当前线程。</p>
<ol>
<li>当一个任务提交给线程池时，如果当前线程池中线程数量少于核心线程数，会重新创建新的线程执行这个任务，然后通过线程安全的方法更新当前线程数。注意，当提交一个任务给线程池时，线程池会创建一个核心线程来执行，即使其他核心线程空闲，直到核心线程达到预设值。</li>
<li>如果当前线程数已经大于或者等于核心线程数，那会尝试判断阻塞队列是否已满，未满的话将任务加入到阻塞队列中。</li>
<li>已满则判断当前线程池数量是否小于最大线程数量，如果是的话，创建工作线程执行，否则的话执行拒绝策略。</li>
</ol>
<h2 id="线程池参数说明"><a href="#线程池参数说明" class="headerlink" title="线程池参数说明"></a>线程池参数说明</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,//核心线程数</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">int</span> maximumPoolSize, //最大工作线程数，不能小于corePoolSize</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">long</span> keepAliveTime, //非核心线程超时时间，闲置时间超过会被销毁</span></span></span><br><span class="line"><span class="params"><span class="function">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                          BlockingQueue&lt;Runnable&gt; workQueue, //用于保存等待执行的任务的阻塞队列</span></span></span><br><span class="line"><span class="params"><span class="function">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                          RejectedExecutionHandler handler //拒绝策略)</span></span></span><br></pre></td></tr></table></figure>
<p>阻塞队列有很多种,newCachedThreadPool使用SynchronousQueue，这种阻塞队列不存储任务，每个插入操作必须等待一个线程执行取出操作，否则插入线程阻塞。newFixedThreadPool则使用LinkedBlockingQueue。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a92003860de484f9303698e8db22999~tplv-k3u1fbpfcp-watermark.image" alt="handle.png"></p>
<p>拒接策略分为四种，分别是直接只用调用者所在线程执行任务、直接抛出异常、丢弃队列里等待最长时间的任务，执行当前任务、或者直接丢弃掉当前任务。</p>
<h2 id="配置线程池"><a href="#配置线程池" class="headerlink" title="配置线程池"></a>配置线程池</h2><p>根据不同的情况配置线程池：</p>
<ul>
<li>根据任务性质，比如是CPU密集型还是IO密集型，CPU密集型应该配置尽可能少的线程，防止线程持续等待CPU分配时间，IO密集型就可以多一些线程，因为大部分线程可能在等待IO；</li>
<li>任务优先级，是否有些任务是高优执行的，可以使用ProrityQueue作为阻塞队列。</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/02/10/Java%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/">Java中的并发工具类</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-02-10</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/">技术积累</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Java/">Java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91/">并发</a></span><div class="content"><meta name="referrer" content="no-referrer" />



<p>Java中有许多工具类可以在并发场景中使用，简化并发编程难度，提高程序准确性。</p>
<h2 id="CountDaowLatch"><a href="#CountDaowLatch" class="headerlink" title="CountDaowLatch"></a>CountDaowLatch</h2><p>可以实现类似于fork-join模型提供的功能，在多线程场景中，用于等待其他线程完成的线程可以调用countDownLatch的await方法进入等待状态，只有当其他线程将CountDownLatch中保存的值递减到0时，等待线程才会继续运行。</p>
<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>)；</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread threadOne = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;continue&quot;</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                System.out.println(<span class="string">&quot;continue&quot;</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadOne.start();</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f273d1dd6c2147cdb5145ee3dfa042ac~tplv-k3u1fbpfcp-watermark.image" alt="answer.png"></p>
<p>运行结果总是相同，主线程在运行到await时，会进入等待状态，只有当子线程两次执行完countDown之后，主线程才会继续执行。</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>查看CountDownLatch的实现，可以看到在new一个CountDownLatch时，需要一个int类型的参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;count &lt; 0&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Sync是CountDownLatch的一个继承了AbstractQueuedSynchronizer的内部类，用于实现同步控制，具有一些列加锁和解锁的方法。构造CountDownLatch时传入的参数最终用来设置一个被volatile修饰的属性state。这个state值可以理解了当前所有线程可重入的获得了多少锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>countDown会将当前的state值减1，这可以理解为释放一把锁的过程。</p>
<p>当主线程调用await方法之后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果当前的state没有减到0，主线程就会去执行doAcquireSharedInterruptibly,这个方法会使得主线程不断死循环的去获取“锁”，或者直到中断，直到state减少到0，主线程才能得到“锁”，解除循环，继续执行。</p>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><h3 id="使用方式-1"><a href="#使用方式-1" class="headerlink" title="使用方式"></a>使用方式</h3><p>可以用于做流量控制，限制多线程对有限资源的访问，在多并发场景下，如果资源数量有限，只能够支持有限的线程的使用，可以使用信号量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_COUNT = <span class="number">30</span>; <span class="comment">//线程规模</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore s = <span class="keyword">new</span> Semaphore(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span> * THREAD_COUNT; i++) &#123; <span class="comment">//任务数量远大于线程数</span></span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        s.acquire();  <span class="comment">//获取信号量</span></span><br><span class="line">                        printThreadCount();</span><br><span class="line">                        s.release(); <span class="comment">//释放信号量</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">printThreadCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前可用许可证数：&quot;</span>+s.availablePermits() + <span class="string">&quot; 等待线程数&quot;</span> + s.getQueueLength());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d5e7abb9e634cf0833e479611c11b0b~tplv-k3u1fbpfcp-watermark.image" alt="ww.png"></p>
<h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">    setState(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在初始化Semaphore时，默认构造非公平的同步器，传入参数为信号量的值。<br>在线程执行到acquire时，会尝试可中断的去获取信号量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)    </span><br><span class="line">        doAcquireSharedInterruptibly(arg);  <span class="comment">//1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> available = getState();</span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires;<span class="comment">//目前剩余信号量，小于0证明已经无可用</span></span><br><span class="line">        <span class="comment">//尝试判断，小于0或者原子重置信号量值失败，都会返回负值，然后进入等待队列</span></span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在释放信号量以后，会通过原子操作给state值加一，如果当前state的值大于0，会在等待队列中唤醒队列首部的线程去获得信号量。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/02/10/Java%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E7%B1%BB/">Java中的原子类</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-02-10</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/">技术积累</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Java/">Java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91/">并发</a></span><div class="content"><meta name="referrer" content="no-referrer" />



<p>在多线程读写共享变量的场景中，很容易出现数据竞争，导致数据不一致。Java提供了<strong>synchronized</strong>关键字和<strong>Lock</strong>接口来保证多线程对同步块的有序访问，但是这两种方式都需要隐式或者显式的获取锁，性能开销略大。Java的Atomic包提供了多个原子操作类，可以安全、高效、简单的实现在多线程场景下读写变量。Atomic包中的类基本上都是使用Unsafe实现的包装类。</p>
<h2 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h2><p>包括诸多方法实现整型数据的原子操作。比如对于整数的递增操作i++，由于这一操作并不是原子的，所以即便使用volatile修饰也不能保证线程安全，这种场景就可以使用AtomicInteger的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically increments by one the current value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the updated value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下通过AtomitInteger的addAndGet方法来分析这一原子类是如何实现线程安全的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically adds the given value to the current value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> delta the value to add</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> valueOffset the value memory address.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the updated value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">addAndGet</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, delta) + delta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>var5是通过native方法取得的当前变量的值，compareAndSwapInt通过原子操作，将预期的的结果var5+var4替换为当前变量的值var5，如果方法成功就，compareAndSwapInt返回ture，循环结束，如果返回false，说明有其他线程在这段时间修改了当前变量的值，会重新通过循环获取var5，继续重试。</p>
<h2 id="AtomicBoolean"><a href="#AtomicBoolean" class="headerlink" title="AtomicBoolean"></a>AtomicBoolean</h2><p>实现原理与AtomicInteger基本相同，核心思想是将true和false映射为1和0。int类型的value存储的就是当前AtomicBoolean的状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new &#123;<span class="doctag">@code</span> AtomicBoolean&#125; with the given initial value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialValue the initial value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AtomicBoolean</span><span class="params">(<span class="keyword">boolean</span> initialValue)</span> </span>&#123;</span><br><span class="line">    value = initialValue ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically sets to the given value and returns the previous value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newValue the new value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">boolean</span> newValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> prev;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = get();</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSet(prev, newValue));</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">boolean</span> expect, <span class="keyword">boolean</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> e = expect ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">//将boolean类型映射为int类型</span></span><br><span class="line">    <span class="keyword">int</span> u = update ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, e, u);<span class="comment">//通过原子操作更新当前值。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原子更新数组"><a href="#原子更新数组" class="headerlink" title="原子更新数组"></a>原子更新数组</h2><p>更新数组的值是通过调用其他原子更新基本类型或者引用类型来实现的，重点在于通过数组下标获得当前值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">updateAndGet</span><span class="params">(<span class="keyword">int</span> i, IntUnaryOperator updateFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> offset = checkedByteOffset(i);<span class="comment">//得到下标在内存中的地址</span></span><br><span class="line">    <span class="keyword">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = getRaw(offset);</span><br><span class="line">        next = updateFunction.applyAsInt(prev);<span class="comment">//转为int</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSetRaw(offset, prev, next));</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在内存中取得当前值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getRaw</span><span class="params">(<span class="keyword">long</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getIntVolatile(array, offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以原子方式修改数组偏移量的值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compareAndSetRaw</span><span class="params">(<span class="keyword">long</span> offset, <span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(array, offset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="原子更新引用"><a href="#原子更新引用" class="headerlink" title="原子更新引用"></a>原子更新引用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> longkai;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReferenceTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AtomicReference&lt;User&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;User&gt;();</span><br><span class="line">        User firstUser = <span class="keyword">new</span> User(<span class="string">&quot;long&quot;</span>, <span class="number">23</span>);</span><br><span class="line">        atomicReference.set(firstUser);</span><br><span class="line">        User secondUser = <span class="keyword">new</span> User(<span class="string">&quot;kai&quot;</span>, <span class="number">24</span>);</span><br><span class="line">        atomicReference.compareAndSet(firstUser, secondUser);</span><br><span class="line">        System.out.println(atomicReference.get().getName());</span><br><span class="line">        System.out.println(atomicReference.get().getAge());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V expect, V update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>通过查看源码，最后发现Unfase类只提供了三种CAS方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果当前值为var4，则将值更新为var5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object var1, <span class="keyword">long</span> var2, Object var4, Object var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">long</span> var4, <span class="keyword">long</span> var5)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>与AtomicBoolean类似，原子更新char、short、float、double可以实现。CAS算法是一种乐观锁的实现思想，在更新变量之前不对更新操作进行加锁，而是在更新之后再去看当前变量内存地址的值有没有发生改变，如果没有，就将希望更新的值写入到内存，如果发生了更改，则继续重试。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/11/19/%E5%9C%A8%E5%86%AC%E5%AD%A3%E5%92%8C%E5%8C%97%E4%BA%AC%E5%86%8D%E6%AC%A1%E7%9B%B8%E9%81%87/">在冬季和北京再次相遇</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-11-19</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E4%BA%BA%E7%94%9F%E5%B1%A5%E5%8E%86/">人生履历</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%AE%9E%E4%B9%A0/">实习</a></span><div class="content"><p>昨天晚上八点到的北京，从广州穿着短袖飞越两千多公里，下飞机以后穿着和路人显得格格不入，大家都是穿着厚厚的棉袄了。</p>
<p>走了二十多分钟到之前订的民宿里暂住一晚，一路上是那种好久没有感觉过的冷。房东是个大学老师，很客气。十一点吃完外卖直接睡下了，感觉还是没有住酒店轻松，民宿总感觉不方便，比如担心声音大了一点惹主人家不高兴。</p>
<p>早上起来赶到回龙观和房东谈房子，感觉北京的空气比前些年要好很多了，很明显有那种高纬度地区天空纯洁的感觉。前几天从广州寄的被子今天刚好送到，不早不晚，可以直接用上。</p>
<p>秋招的offer拿到的全是北京的公司。在面试时很多面试官都会问我为什么要来北京？和同学说我打算去北京，他们也会问为什么要去那么远呢？北京空气质量不好，气候干燥，交通还拥堵。这些都是我真真实实要面对的问题，</p>
<p>但是我还是没有打算去其他城市，我觉得北京对于我有一种莫名的吸引力，或许是他深厚的文化底蕴，或许是他领先的经济发展水平，或者是他各类的活跃人才，这些也许其他城市也有，但总不能和北京比肩。在北京工作的经历会是一段富有意义的经历，这样的经历，越早越好。</p>
<p>近来也会思考人生的意义，以前觉得人生应该最求快乐，怎样快乐就怎样去度过一生，但是现在不这么觉得了，人生应该是追求充实，同样要去接纳苦难和波澜不惊，应该去领略各式各样的人生，如果总是快乐的，不免显得太单调无味。</p>
<p>距离今年春节已经不足三个月了，发现手里的事情还蛮多的，而且都有难度，毕业设计已经提上日程，目前还没有方向，想要在春招转后端开发，但是要学的东西还有很多，在快手的实习工作量应该会很足，也担心一些工作可能做不好，嗯，是的，不会说做完什么事就没事了，事情永远一件接一件，那，干就完了。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/26/%E6%B5%B7%E5%A4%96%E6%BB%A9%E4%B9%8B%E5%A4%9C/">上海外滩之夜</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-26</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E4%BA%BA%E7%94%9F%E5%B1%A5%E5%8E%86/">人生履历</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%AE%9E%E4%B9%A0/">实习</a></span><div class="content"><meta name="referrer" content="no-referrer" />


<p>来上海一周了，一切都好，因为自己前端基础比较薄弱，每天在公司会学很多东西，感觉很充实，很有成就感，但是每当晚上八九点独自一人回到住处，强烈的孤独感就会袭来，是一种让人心慌，不知所措的感觉。</p>
<p>昨天是星期六，来这里以后的第一个休息日，但是对这里都不熟，也不知道去哪里，只好一觉睡到十点。下午复习了一下课程，决定晚上出去走走，否则漫漫长夜实在难挨。东方明珠是小学课本里出现的，也一直作为上海的标志和上海联系在一起，出了地铁就看到了，但真的略感失落，因为她好像不是想象中的那么高大，尤其是在和周围那么多金融大厦相比。</p>
<p>走在黄埔江边，和王金梅聊了一路，感觉就没那么孤独了，孤独应该是要倾诉的吧。现在可以好好聊聊真心话的朋友真的越来越少了，不知为何，只能接受。天南地北聊了很久，我都忘记自己已经走了多远了。在意识到应该回去了才发现距离地铁站已经很远了，狠心想打车回去，奈何手机还没等到车来就没电关机了。立刻意识到情况不妙，地铁停运，手机没电，可能回不去了，只能趁现在江边还有人赶紧返回东方明珠附近，那里应该相对安全，一路快走，脚掌也不疼了，本来刚才散步就有点疼了。</p>
<p>已经十一点半了才走回到东方明珠塔下，幸好有一个保安亭可以充电，本来想央求他收容一晚上的，无奈他太不近人情了。一点钟充电差不多了，也不打算再去找住处了，现在到处跑也不安全，就在保安亭旁边角落做一晚上吧，和保安在一起应该更安全一点。从五个小时，一万八千秒倒数，晚上是真的有点冷，最冷的时候应该是凌晨四点钟的时候。先是坐地板上，发现地板太僵了，然后站着，站不动就蹲着，期待着黎明的到来。凌晨三点钟看到一个中年男人来翻垃圾桶，生活是有多难呢？凌晨四点钟就有人起床锻炼了，真的佩服；偶然听到那个保安和朋友聊天，他拒绝去工厂，太累了，还是当保安轻松，我就在想难道你可以做一辈子保安吗？凌晨四点钟就鸟儿就开始出来觅食了，叽叽喳喳的好多，我还以为城市没有鸟呢。</p>
<p>熬到五点，已经是黎明了，还好回去睡两个小时还赶得上上班。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/20/%E5%9C%A8%E7%BE%8E%E5%9B%A2%E7%82%B9%E8%AF%84%E7%9A%84%E7%AC%AC%E4%B8%80%E5%A4%A9/">在美团点评的第一天</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-20</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E4%BA%BA%E7%94%9F%E5%B1%A5%E5%8E%86/">人生履历</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%AE%9E%E4%B9%A0/">实习</a></span><div class="content"><p>今天是入职美团点评开始实习的第一天，是来到上海的第三天。在第一天晚上住的那个酒店里放了一个体重称，称了一下体重，133斤，果然，这三个月假期肥了7斤，比大学两年半肥的还要多。对于我来说，没有学习和工作的氛围，自律的学习和生活就不可能。</p>
<p>赶紧滚出舒适圈，今年行情不好，还是早些谋划出路。当混子的时间长了，连方向都分不清，先把三明北的高铁票买成了三明站，幸好没耽误下一程，然后把自己工作的地点弄错，之前联系要租的房子前功尽弃，在找房子的前一天晚上十二点还临时上网找房子，又把酒店定在了和公司截然相反的方向，行李箱都在漫长的换乘地铁的过程中拉坏掉，真的是路遥马亡。</p>
<p>今天入职，真正的开始把知识运用到工程。在办理入职手续的时候见到了很多也是今天入职的同龄人，感觉挺好的，年轻人比较多。HR联系徐斌学长接到了我，然后见到了部门leader，就是二轮面试的面试官，还记得当时聊了一个多小时，虽然很多问题我都答不出来，他也会给我解答一下，真人比视频上年轻是真的。部门工位满了，只能到隔壁部门借坐两天，这也挺好，和他们在一起自己那些low比操作怕是要被笑死。mentor是个应该毕业一两年的女生，虽然年纪轻轻，但是项目构思、技术表达都非常严谨和清晰，在今天晚上的小组周会上可见一斑。</p>
<p>八点下班走人，住得近真的好，可以步行上下班，早晚高峰挤地铁的事情我是不用体验了。回来接到了爸爸的电话，多是些叮嘱我这个涉世未深的小孩应该如何处理职场的人情世故。还记得在家面试的时候，每次面试妈妈都会问这家公司是哪里的，其实说了在哪个城市她也不知道，也还是要问问，应该是希望工作得城市不要太远吧。</p>
<p>要开始接收新任务了，还是赶紧学习，在被认出是菜鸡之前变得稍微强一点。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/09/%E5%AF%B9%E6%AF%8F%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%9B%BE%E5%88%B0%E8%BE%BE%E7%9A%84%E5%9C%B0%E6%96%B9%EF%BC%8C%E9%83%BD%E8%A6%81%E5%BF%83%E6%80%80%E5%90%91%E5%BE%80/">对每一个不曾到达的地方，都要心怀向往</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-09</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%AE%9E%E8%B7%B5%E5%BF%83%E5%BE%97/">实践心得</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E6%88%90%E9%95%BF/">成长</a></span><div class="content"><p>放假已经快三个月了，因为疫情，才可以和爸妈在一起那么久，过完年就开始复习找实习，也准备了快三个月了，真的非常幸运，拿到了美团点评的Android工程师实习offer，否则我现在真的会焦虑死吧。</p>
<p>年后就在想，实习应该找什么岗位呢，自己大学学习的那些课程好像不足以应对工作，好像做什么都要从零开始，最终决定选择Android开发，是因为算法岗自己肯定不行，后台开发竞争太大了，前端庞杂难以短时间掌握，iOS开发目前没有硬件练习，测试门槛太低了，就只有Android是最优解了。整个准备的过程需要复习和学习的东西还是蛮多的，计算机网络、操作系统、数据库、Java、Android、JVM、设计模式等都要去学习，还要时常刷一点算法题。整个过程有一种山重水复疑无路，柳暗花明又一村的感觉。</p>
<p>3月10左右开始投简历，都忘记投了多少家公司了，每天都会去看一下简历状态，等待面试真的是很难受的一个过程。一开始面试的是蘑菇街，第一轮面试就挂掉了，然后小米、盛趣游戏、字节跳动、腾讯、CVTE等相继挂掉，虽然每一轮面试都入真准备，但是小厂需要可以直接干活的，大厂需要学习能力各方面都很优秀的，那我真的就没有去处了。</p>
<p>我一直感觉我是一个很幸运的人，特别是在一些人生的关键节点，都会遇到贵人相助，这次也不例外。美团点评也算大厂了，在美团点评面试之前就有一位美团点评iOS工程师打电话给我，希望我转iOS，让我好好准备笔试，这给我很好的心理暗示，然后面试的时候是一位女生面试官，人很友好，问的问题很简单，问题答不对也会引导，40分钟就结束面试了，当天就收到了第二次面试和第三次面试的邀请，这又给我了很好的心理暗示，难道默认第二轮面试通过吗？我想得太美了，第二轮是一个leader，一个多小时的面试都是基础知识轰炸，虽然很大都没有答出来，但是他还是给我过了。第三轮面试相对就比较轻松了，面试官人很好，天南地北的都聊。第二天就收到了offer call，下周一就收到了offer通知，曾为此不遗余力的复习，也曾辗转反侧的煎熬等待，终于所得届时所想，心中喜悦之情，难以言表。</p>
<p>在最近几次面试中，反复被问到了了对职业生涯有什么规划，没有想过的问题，自然回答得一团糟，但这个问题不可以回避，也无法回避，真的需要规划自己得职业生涯了，那种庸庸碌碌的校园生活所剩无几了。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/12/28/hello2020/">想要问问你，生活可如意</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-28</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/">生活随笔</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E6%80%9D%E8%80%83/">思考</a></span><div class="content"><p>在过3天就是2020年了，又一个十年的伊始。</p>
<p>回想过去十年应该是很惬意的十年，小学到初中在到高中，还有不紧不慢的大一大二两年，都过得潇洒恣意，也取得些许成就，至少无愧于自己也无愧于亲友。</p>
<p>现在的我说话已经时常用成年人打头了，成年人不能畏畏缩缩没有担当、成年人不能理所当然的继续成为家里的负担、成年人不能一事无成。</p>
<p>越是经常这样想就越是觉得失落。今年一心想着修学分，选课选得多了一些，再加上自己的资质是在过于平庸，一个学期下来整天围着作业打转，上半学期还好，还能勉强跟上，下半学期尤其是接近期末这段时间，只能是糊弄作业了，为此时常觉得难受。这种感觉在和同学们的对比总尤为强烈，自己进步得实在是太慢了，再仔细想想，自己有进步吗？</p>
<p>暂时先麻木吧，心为形役，挨过这个学期再说。</p>
<p>今年的下半年开始，考研和实习应该是思考得最为频繁得两件事。考研有风险，而且对经济独立有一种向往，所以时常在想着怎么开始第一份实习；感觉自己基础还不够扎实，尚不能胜任技术含量高得工作，而且担心本科学历会成为职业生涯的瓶颈。就是一个选择题，想了一个学期也没想明白，后来就决定先实习吧，一些主意光想就如同空中楼阁，不切实际，不如职场走一圈，去体会一下本科就业是否适合自己，就这样，路是走出来的，不是想出来的，适合什么亲自体验一番就知道了。</p>
<p>苒苒时光，当然不乏感动与快乐。</p>
<p>前两天哥哥在家人群里告知今年可能赶不上年夜饭了，让我们不要等他吃饭了，我先是厌恶它们公司放假晚而后只是无可奈何，爸爸看到消息以后说了一句“不怕伐个车去高铁站接你”，而后又说“我去高铁站联系车等你”，心里是感动的感觉，父母在的地方都是家，什么都不用怕。</p>
<p>每个人都开始忙碌各自的事，疏远的人越来越多，能够时常问候的人越来越少。和王金梅相识快十年了，感情依旧，幸甚。</p>
<p>今年课外文学阅读21本，还好阅读这个习惯没有被荒废掉。《霍乱时期的爱情》这本书使我最为震撼，贯穿一生的爱情，读来让人唏嘘。</p>
<p>一直想学口琴的，买了一把很贵的口琴却束之高阁，三分钟热度要不得。</p>
<p>今年有幸出境德国游学一次，有什么收获也说不上来，对自己的影响却是有的，时常想起自己说过好好学习，积极生活，山河俊秀，不可辜负。这个世界那么美，那么多原子聚合成一个现在的我在这宇宙千万年里就那么一次，真应该珍惜短短剑，去走遍山川湖海。</p>
<p>对下一个十年没什么规划，继续努力吧。</p>
<p>2020，对我好一点。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/11/16/%E7%9C%9F%E7%88%B1%E4%B9%8B%E4%B8%8A%EF%BC%8C%E5%8B%BF%E9%97%AE%E6%97%B6%E5%85%89/">真爱之上，勿问时光</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-11-16</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%94/">阅读随笔</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E6%80%9D%E8%80%83/">思考</a></span><div class="content"><p>船长看了看费尔明娜·达萨，在她睫毛上看到初霜的闪光。然后，他又看了看弗洛伦蒂诺·阿里萨，看到的是他那不可战胜的决心和勇敢无畏的爱。这份迟来的顿悟吓了他一跳，原来是生命，而非死亡，才是没有止境的。</p>
<p>“见鬼，那您认为我们这样来来回回的究竟走到什么时候呢？”他问。</p>
<p>在五十三年七个月零十天以来的日日夜夜，弗洛伦蒂诺·阿里萨一直都准备好了答案。</p>
<p>“一生一世。”他说。</p>
<p>断断续续读完《霍乱时期的爱情》已经快花了两个月的时间，看着书中弗洛伦蒂诺·阿里萨和费尔明娜·达萨从青年时期的青涩爱情中走失彼此，错过一生，再到生命的最后放下世俗成见，勇敢的走到一起，既唏嘘爱情的脆弱，也震撼于爱情的坚强。</p>
<p>年轻时的弗洛伦蒂诺·阿里萨曾独自一人坐在花园中的一条不易被发现的长椅上，在杏树的树荫下假装读一本诗集，直到看到那位可望不可及的姑娘走过。一念既起，执念终生。</p>
<p>弗洛伦蒂诺·阿里萨和费尔明娜·达萨也曾在情窦初开之时互相写信，通过文字悄无声息的传递着对彼此的思念和情意。</p>
<p>费尔明娜·达萨的父亲希望她的女儿通过一桩美满的婚事获得新生，两个年轻人脆弱且卑微，没有站在一起对抗世俗的风雨，一个短暂的远走他乡，一个被迫与父亲远游历练，在安排之下嫁给了声名显赫的医生。</p>
<p>弗洛伦蒂诺·阿里萨没有放下执念，跳出时光洪流，开始一生的等待。虽然费尔明娜·达萨已为人妻，在在柴米油盐中经历着所有人都会经历的酸甜苦辣、争吵和欢笑，但是弗洛伦蒂诺·阿里萨安心的修缮好房子就，并且决心一生独身，他自然的等待，等待费尔明娜·达萨的丈夫死去，再让他有机会得到她的爱。他的心是觉得忠诚的，虽然身体曾经无数次出轨。</p>
<p>长达五十一年等待后费尔明娜·达萨的丈夫意外死亡，弗洛伦蒂诺·阿里萨第一时间开始了对她的最求，回忆瞬间涌来，仿佛五十余年的时光不曾流逝。这一次，费尔明娜·达萨已经不再惧怕世俗压力，她说：“一个世纪以前，人们毁掉了我和这个可怜男人的生活，因为我们太年轻；现在又想在我们身上故技重施，因为我们太老了，让他们见鬼去吧，如果说我们这些寡妇有什么优势的话，那就是再也没有人可以对我们发号施令了。”</p>
<p>两个人在船上度过了最快乐的时光，也许是最后的时光。</p>
<p>读这本书的过程中多次想起一句歌词：假如我年少有为不自卑，懂得什么是珍贵；假如我年少有为知进退，才不会让你替我受罪。经常会看到很多人遗憾在最想照顾一个人的时候没有足够的勇气和能力，等到失去之后，虽然能力已经匹配，也有了抵抗流言的勇气，却也只能是一个人独自挣扎了，爱的人早就走散了，不甘心却也再也求不得。</p>
<p>这样的事情几千年了一直都有，别人的故事一直在听，自己却怎么也学不会的，真正要懂的道理，只有自己亲身经历并为之付出代价才能学会的，代价越惨重，领悟越深刻，这个时候道理记住与否多半不重要了，失去了就真的失去了，有些人有些事一辈子只能有一次。</p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(http://images.zhulk3.cn/blog/sky.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2023 By hohnor</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>