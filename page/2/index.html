<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="k子的小天地"><meta name="keywords" content=""><meta name="author" content="hohnor"><meta name="copyright" content="hohnor"><title>甜茶不贵</title><link rel="shortcut icon" href="/melody-favicon.png"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?6216f76ee0b952906ada65e98f09e4a1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '6.0.0'
} </script><meta name="generator" content="Hexo 6.0.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">hohnor</div><div class="author-info__description text-center">k子的小天地</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">25</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">11</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">6</span></a></div></div></div><nav id="nav" style="background-image: url(https://images.zhulk3.xyz/blog/sky.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">甜茶不贵</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="site-info"><div id="site-title">甜茶不贵</div><div id="site-sub-title"></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2022/02/10/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8/">线程池的使用</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-02-10</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/">技术积累</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Java/">Java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91/">并发</a></span><div class="content"><meta name="referrer" content="no-referrer" />

<h2 id="使用线程池的益处"><a href="#使用线程池的益处" class="headerlink" title="使用线程池的益处"></a>使用线程池的益处</h2><ul>
<li>避免重复创建线程执行任务，减少了创建线程和销毁线程需要的时间开销和性能开销；</li>
<li>提高任务响应速度，线程池中通常缓存有线程，当提交任务以后，可迅速执行；</li>
<li>避免了无规则的创建大量线程，导致大量线程排队等待CPU，响应速度变慢；</li>
</ul>
<h2 id="线程池处理流程"><a href="#线程池处理流程" class="headerlink" title="线程池处理流程"></a>线程池处理流程</h2><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/59976e0fd2fe42d9862b3db3be1aa4d1~tplv-k3u1fbpfcp-watermark.image" alt="stage.png"></p>
<p>我们可以调用线程池的execute和submit方法来提交任务，提交参数都是一个Runnable实例，不同的是，submit会返回一个Future类型的对象，可以通过future对象的get方法获得返回值，注意这个方法会阻塞当前线程。</p>
<ol>
<li>当一个任务提交给线程池时，如果当前线程池中线程数量少于核心线程数，会重新创建新的线程执行这个任务，然后通过线程安全的方法更新当前线程数。注意，当提交一个任务给线程池时，线程池会创建一个核心线程来执行，即使其他核心线程空闲，直到核心线程达到预设值。</li>
<li>如果当前线程数已经大于或者等于核心线程数，那会尝试判断阻塞队列是否已满，未满的话将任务加入到阻塞队列中。</li>
<li>已满则判断当前线程池数量是否小于最大线程数量，如果是的话，创建工作线程执行，否则的话执行拒绝策略。</li>
</ol>
<h2 id="线程池参数说明"><a href="#线程池参数说明" class="headerlink" title="线程池参数说明"></a>线程池参数说明</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,//核心线程数</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">int</span> maximumPoolSize, //最大工作线程数，不能小于corePoolSize</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">long</span> keepAliveTime, //非核心线程超时时间，闲置时间超过会被销毁</span></span></span><br><span class="line"><span class="params"><span class="function">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                          BlockingQueue&lt;Runnable&gt; workQueue, //用于保存等待执行的任务的阻塞队列</span></span></span><br><span class="line"><span class="params"><span class="function">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                          RejectedExecutionHandler handler //拒绝策略)</span></span></span><br></pre></td></tr></table></figure>
<p>阻塞队列有很多种,newCachedThreadPool使用SynchronousQueue，这种阻塞队列不存储任务，每个插入操作必须等待一个线程执行取出操作，否则插入线程阻塞。newFixedThreadPool则使用LinkedBlockingQueue。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a92003860de484f9303698e8db22999~tplv-k3u1fbpfcp-watermark.image" alt="handle.png"></p>
<p>拒接策略分为四种，分别是直接只用调用者所在线程执行任务、直接抛出异常、丢弃队列里等待最长时间的任务，执行当前任务、或者直接丢弃掉当前任务。</p>
<h2 id="配置线程池"><a href="#配置线程池" class="headerlink" title="配置线程池"></a>配置线程池</h2><p>根据不同的情况配置线程池：</p>
<ul>
<li>根据任务性质，比如是CPU密集型还是IO密集型，CPU密集型应该配置尽可能少的线程，防止线程持续等待CPU分配时间，IO密集型就可以多一些线程，因为大部分线程可能在等待IO；</li>
<li>任务优先级，是否有些任务是高优执行的，可以使用ProrityQueue作为阻塞队列。</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/02/10/Java%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/">Java中的并发工具类</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-02-10</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/">技术积累</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Java/">Java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91/">并发</a></span><div class="content"><meta name="referrer" content="no-referrer" />



<p>Java中有许多工具类可以在并发场景中使用，简化并发编程难度，提高程序准确性。</p>
<h2 id="CountDaowLatch"><a href="#CountDaowLatch" class="headerlink" title="CountDaowLatch"></a>CountDaowLatch</h2><p>可以实现类似于fork-join模型提供的功能，在多线程场景中，用于等待其他线程完成的线程可以调用countDownLatch的await方法进入等待状态，只有当其他线程将CountDownLatch中保存的值递减到0时，等待线程才会继续运行。</p>
<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>)；</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread threadOne = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;continue&quot;</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                System.out.println(<span class="string">&quot;continue&quot;</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadOne.start();</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f273d1dd6c2147cdb5145ee3dfa042ac~tplv-k3u1fbpfcp-watermark.image" alt="answer.png"></p>
<p>运行结果总是相同，主线程在运行到await时，会进入等待状态，只有当子线程两次执行完countDown之后，主线程才会继续执行。</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>查看CountDownLatch的实现，可以看到在new一个CountDownLatch时，需要一个int类型的参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;count &lt; 0&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Sync是CountDownLatch的一个继承了AbstractQueuedSynchronizer的内部类，用于实现同步控制，具有一些列加锁和解锁的方法。构造CountDownLatch时传入的参数最终用来设置一个被volatile修饰的属性state。这个state值可以理解了当前所有线程可重入的获得了多少锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>countDown会将当前的state值减1，这可以理解为释放一把锁的过程。</p>
<p>当主线程调用await方法之后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果当前的state没有减到0，主线程就会去执行doAcquireSharedInterruptibly,这个方法会使得主线程不断死循环的去获取“锁”，或者直到中断，直到state减少到0，主线程才能得到“锁”，解除循环，继续执行。</p>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><h3 id="使用方式-1"><a href="#使用方式-1" class="headerlink" title="使用方式"></a>使用方式</h3><p>可以用于做流量控制，限制多线程对有限资源的访问，在多并发场景下，如果资源数量有限，只能够支持有限的线程的使用，可以使用信号量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_COUNT = <span class="number">30</span>; <span class="comment">//线程规模</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore s = <span class="keyword">new</span> Semaphore(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span> * THREAD_COUNT; i++) &#123; <span class="comment">//任务数量远大于线程数</span></span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        s.acquire();  <span class="comment">//获取信号量</span></span><br><span class="line">                        printThreadCount();</span><br><span class="line">                        s.release(); <span class="comment">//释放信号量</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">printThreadCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前可用许可证数：&quot;</span>+s.availablePermits() + <span class="string">&quot; 等待线程数&quot;</span> + s.getQueueLength());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d5e7abb9e634cf0833e479611c11b0b~tplv-k3u1fbpfcp-watermark.image" alt="ww.png"></p>
<h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">    setState(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在初始化Semaphore时，默认构造非公平的同步器，传入参数为信号量的值。<br>在线程执行到acquire时，会尝试可中断的去获取信号量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)    </span><br><span class="line">        doAcquireSharedInterruptibly(arg);  <span class="comment">//1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> available = getState();</span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires;<span class="comment">//目前剩余信号量，小于0证明已经无可用</span></span><br><span class="line">        <span class="comment">//尝试判断，小于0或者原子重置信号量值失败，都会返回负值，然后进入等待队列</span></span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在释放信号量以后，会通过原子操作给state值加一，如果当前state的值大于0，会在等待队列中唤醒队列首部的线程去获得信号量。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/02/10/Java%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E7%B1%BB/">Java中的原子类</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-02-10</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/">技术积累</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Java/">Java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91/">并发</a></span><div class="content"><meta name="referrer" content="no-referrer" />



<p>在多线程读写共享变量的场景中，很容易出现数据竞争，导致数据不一致。Java提供了<strong>synchronized</strong>关键字和<strong>Lock</strong>接口来保证多线程对同步块的有序访问，但是这两种方式都需要隐式或者显式的获取锁，性能开销略大。Java的Atomic包提供了多个原子操作类，可以安全、高效、简单的实现在多线程场景下读写变量。Atomic包中的类基本上都是使用Unsafe实现的包装类。</p>
<h2 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h2><p>包括诸多方法实现整型数据的原子操作。比如对于整数的递增操作i++，由于这一操作并不是原子的，所以即便使用volatile修饰也不能保证线程安全，这种场景就可以使用AtomicInteger的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically increments by one the current value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the updated value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下通过AtomitInteger的addAndGet方法来分析这一原子类是如何实现线程安全的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically adds the given value to the current value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> delta the value to add</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> valueOffset the value memory address.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the updated value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">addAndGet</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, delta) + delta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>var5是通过native方法取得的当前变量的值，compareAndSwapInt通过原子操作，将预期的的结果var5+var4替换为当前变量的值var5，如果方法成功就，compareAndSwapInt返回ture，循环结束，如果返回false，说明有其他线程在这段时间修改了当前变量的值，会重新通过循环获取var5，继续重试。</p>
<h2 id="AtomicBoolean"><a href="#AtomicBoolean" class="headerlink" title="AtomicBoolean"></a>AtomicBoolean</h2><p>实现原理与AtomicInteger基本相同，核心思想是将true和false映射为1和0。int类型的value存储的就是当前AtomicBoolean的状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new &#123;<span class="doctag">@code</span> AtomicBoolean&#125; with the given initial value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialValue the initial value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AtomicBoolean</span><span class="params">(<span class="keyword">boolean</span> initialValue)</span> </span>&#123;</span><br><span class="line">    value = initialValue ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically sets to the given value and returns the previous value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newValue the new value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">boolean</span> newValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> prev;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = get();</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSet(prev, newValue));</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">boolean</span> expect, <span class="keyword">boolean</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> e = expect ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">//将boolean类型映射为int类型</span></span><br><span class="line">    <span class="keyword">int</span> u = update ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, e, u);<span class="comment">//通过原子操作更新当前值。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原子更新数组"><a href="#原子更新数组" class="headerlink" title="原子更新数组"></a>原子更新数组</h2><p>更新数组的值是通过调用其他原子更新基本类型或者引用类型来实现的，重点在于通过数组下标获得当前值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">updateAndGet</span><span class="params">(<span class="keyword">int</span> i, IntUnaryOperator updateFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> offset = checkedByteOffset(i);<span class="comment">//得到下标在内存中的地址</span></span><br><span class="line">    <span class="keyword">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = getRaw(offset);</span><br><span class="line">        next = updateFunction.applyAsInt(prev);<span class="comment">//转为int</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSetRaw(offset, prev, next));</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在内存中取得当前值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getRaw</span><span class="params">(<span class="keyword">long</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getIntVolatile(array, offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以原子方式修改数组偏移量的值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compareAndSetRaw</span><span class="params">(<span class="keyword">long</span> offset, <span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(array, offset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="原子更新引用"><a href="#原子更新引用" class="headerlink" title="原子更新引用"></a>原子更新引用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> longkai;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReferenceTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AtomicReference&lt;User&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;User&gt;();</span><br><span class="line">        User firstUser = <span class="keyword">new</span> User(<span class="string">&quot;long&quot;</span>, <span class="number">23</span>);</span><br><span class="line">        atomicReference.set(firstUser);</span><br><span class="line">        User secondUser = <span class="keyword">new</span> User(<span class="string">&quot;kai&quot;</span>, <span class="number">24</span>);</span><br><span class="line">        atomicReference.compareAndSet(firstUser, secondUser);</span><br><span class="line">        System.out.println(atomicReference.get().getName());</span><br><span class="line">        System.out.println(atomicReference.get().getAge());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V expect, V update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>通过查看源码，最后发现Unfase类只提供了三种CAS方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果当前值为var4，则将值更新为var5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object var1, <span class="keyword">long</span> var2, Object var4, Object var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">long</span> var4, <span class="keyword">long</span> var5)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>与AtomicBoolean类似，原子更新char、short、float、double可以实现。CAS算法是一种乐观锁的实现思想，在更新变量之前不对更新操作进行加锁，而是在更新之后再去看当前变量内存地址的值有没有发生改变，如果没有，就将希望更新的值写入到内存，如果发生了更改，则继续重试。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/11/19/%E5%9C%A8%E5%86%AC%E5%AD%A3%E5%92%8C%E5%8C%97%E4%BA%AC%E5%86%8D%E6%AC%A1%E7%9B%B8%E9%81%87/">在冬季和北京再次相遇</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-11-19</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E4%BA%BA%E7%94%9F%E5%B1%A5%E5%8E%86/">人生履历</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%AE%9E%E4%B9%A0/">实习</a></span><div class="content"><p>昨天晚上八点到的北京，从广州穿着短袖飞越两千多公里，下飞机以后穿着和路人显得格格不入，大家都是穿着厚厚的棉袄了。</p>
<p>走了二十多分钟到之前订的民宿里暂住一晚，一路上是那种好久没有感觉过的冷。房东是个大学老师，很客气。十一点吃完外卖直接睡下了，感觉还是没有住酒店轻松，民宿总感觉不方便，比如担心声音大了一点惹主人家不高兴。</p>
<p>早上起来赶到回龙观和房东谈房子，感觉北京的空气比前些年要好很多了，很明显有那种高纬度地区天空纯洁的感觉。前几天从广州寄的被子今天刚好送到，不早不晚，可以直接用上。</p>
<p>秋招的offer拿到的全是北京的公司。在面试时很多面试官都会问我为什么要来北京？和同学说我打算去北京，他们也会问为什么要去那么远呢？北京空气质量不好，气候干燥，交通还拥堵。这些都是我真真实实要面对的问题，</p>
<p>但是我还是没有打算去其他城市，我觉得北京对于我有一种莫名的吸引力，或许是他深厚的文化底蕴，或许是他领先的经济发展水平，或者是他各类的活跃人才，这些也许其他城市也有，但总不能和北京比肩。在北京工作的经历会是一段富有意义的经历，这样的经历，越早越好。</p>
<p>近来也会思考人生的意义，以前觉得人生应该最求快乐，怎样快乐就怎样去度过一生，但是现在不这么觉得了，人生应该是追求充实，同样要去接纳苦难和波澜不惊，应该去领略各式各样的人生，如果总是快乐的，不免显得太单调无味。</p>
<p>距离今年春节已经不足三个月了，发现手里的事情还蛮多的，而且都有难度，毕业设计已经提上日程，目前还没有方向，想要在春招转后端开发，但是要学的东西还有很多，在快手的实习工作量应该会很足，也担心一些工作可能做不好，嗯，是的，不会说做完什么事就没事了，事情永远一件接一件，那，干就完了。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/26/%E6%B5%B7%E5%A4%96%E6%BB%A9%E4%B9%8B%E5%A4%9C/">上海外滩之夜</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-26</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E4%BA%BA%E7%94%9F%E5%B1%A5%E5%8E%86/">人生履历</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%AE%9E%E4%B9%A0/">实习</a></span><div class="content"><meta name="referrer" content="no-referrer" />


<p>来上海一周了，一切都好，因为自己前端基础比较薄弱，每天在公司会学很多东西，感觉很充实，很有成就感，但是每当晚上八九点独自一人回到住处，强烈的孤独感就会袭来，是一种让人心慌，不知所措的感觉。</p>
<p>昨天是星期六，来这里以后的第一个休息日，但是对这里都不熟，也不知道去哪里，只好一觉睡到十点。下午复习了一下课程，决定晚上出去走走，否则漫漫长夜实在难挨。东方明珠是小学课本里出现的，也一直作为上海的标志和上海联系在一起，出了地铁就看到了，但真的略感失落，因为她好像不是想象中的那么高大，尤其是在和周围那么多金融大厦相比。</p>
<p>走在黄埔江边，和王金梅聊了一路，感觉就没那么孤独了，孤独应该是要倾诉的吧。现在可以好好聊聊真心话的朋友真的越来越少了，不知为何，只能接受。天南地北聊了很久，我都忘记自己已经走了多远了。在意识到应该回去了才发现距离地铁站已经很远了，狠心想打车回去，奈何手机还没等到车来就没电关机了。立刻意识到情况不妙，地铁停运，手机没电，可能回不去了，只能趁现在江边还有人赶紧返回东方明珠附近，那里应该相对安全，一路快走，脚掌也不疼了，本来刚才散步就有点疼了。</p>
<p>已经十一点半了才走回到东方明珠塔下，幸好有一个保安亭可以充电，本来想央求他收容一晚上的，无奈他太不近人情了。一点钟充电差不多了，也不打算再去找住处了，现在到处跑也不安全，就在保安亭旁边角落做一晚上吧，和保安在一起应该更安全一点。从五个小时，一万八千秒倒数，晚上是真的有点冷，最冷的时候应该是凌晨四点钟的时候。先是坐地板上，发现地板太僵了，然后站着，站不动就蹲着，期待着黎明的到来。凌晨三点钟看到一个中年男人来翻垃圾桶，生活是有多难呢？凌晨四点钟就有人起床锻炼了，真的佩服；偶然听到那个保安和朋友聊天，他拒绝去工厂，太累了，还是当保安轻松，我就在想难道你可以做一辈子保安吗？凌晨四点钟就鸟儿就开始出来觅食了，叽叽喳喳的好多，我还以为城市没有鸟呢。</p>
<p>熬到五点，已经是黎明了，还好回去睡两个小时还赶得上上班。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/20/%E5%9C%A8%E7%BE%8E%E5%9B%A2%E7%82%B9%E8%AF%84%E7%9A%84%E7%AC%AC%E4%B8%80%E5%A4%A9/">在美团点评的第一天</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-20</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E4%BA%BA%E7%94%9F%E5%B1%A5%E5%8E%86/">人生履历</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%AE%9E%E4%B9%A0/">实习</a></span><div class="content"><p>今天是入职美团点评开始实习的第一天，是来到上海的第三天。在第一天晚上住的那个酒店里放了一个体重称，称了一下体重，133斤，果然，这三个月假期肥了7斤，比大学两年半肥的还要多。对于我来说，没有学习和工作的氛围，自律的学习和生活就不可能。</p>
<p>赶紧滚出舒适圈，今年行情不好，还是早些谋划出路。当混子的时间长了，连方向都分不清，先把三明北的高铁票买成了三明站，幸好没耽误下一程，然后把自己工作的地点弄错，之前联系要租的房子前功尽弃，在找房子的前一天晚上十二点还临时上网找房子，又把酒店定在了和公司截然相反的方向，行李箱都在漫长的换乘地铁的过程中拉坏掉，真的是路遥马亡。</p>
<p>今天入职，真正的开始把知识运用到工程。在办理入职手续的时候见到了很多也是今天入职的同龄人，感觉挺好的，年轻人比较多。HR联系徐斌学长接到了我，然后见到了部门leader，就是二轮面试的面试官，还记得当时聊了一个多小时，虽然很多问题我都答不出来，他也会给我解答一下，真人比视频上年轻是真的。部门工位满了，只能到隔壁部门借坐两天，这也挺好，和他们在一起自己那些low比操作怕是要被笑死。mentor是个应该毕业一两年的女生，虽然年纪轻轻，但是项目构思、技术表达都非常严谨和清晰，在今天晚上的小组周会上可见一斑。</p>
<p>八点下班走人，住得近真的好，可以步行上下班，早晚高峰挤地铁的事情我是不用体验了。回来接到了爸爸的电话，多是些叮嘱我这个涉世未深的小孩应该如何处理职场的人情世故。还记得在家面试的时候，每次面试妈妈都会问这家公司是哪里的，其实说了在哪个城市她也不知道，也还是要问问，应该是希望工作得城市不要太远吧。</p>
<p>要开始接收新任务了，还是赶紧学习，在被认出是菜鸡之前变得稍微强一点。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/09/%E5%AF%B9%E6%AF%8F%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%9B%BE%E5%88%B0%E8%BE%BE%E7%9A%84%E5%9C%B0%E6%96%B9%EF%BC%8C%E9%83%BD%E8%A6%81%E5%BF%83%E6%80%80%E5%90%91%E5%BE%80/">对每一个不曾到达的地方，都要心怀向往</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-09</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%AE%9E%E8%B7%B5%E5%BF%83%E5%BE%97/">实践心得</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E6%88%90%E9%95%BF/">成长</a></span><div class="content"><p>放假已经快三个月了，因为疫情，才可以和爸妈在一起那么久，过完年就开始复习找实习，也准备了快三个月了，真的非常幸运，拿到了美团点评的Android工程师实习offer，否则我现在真的会焦虑死吧。</p>
<p>年后就在想，实习应该找什么岗位呢，自己大学学习的那些课程好像不足以应对工作，好像做什么都要从零开始，最终决定选择Android开发，是因为算法岗自己肯定不行，后台开发竞争太大了，前端庞杂难以短时间掌握，iOS开发目前没有硬件练习，测试门槛太低了，就只有Android是最优解了。整个准备的过程需要复习和学习的东西还是蛮多的，计算机网络、操作系统、数据库、Java、Android、JVM、设计模式等都要去学习，还要时常刷一点算法题。整个过程有一种山重水复疑无路，柳暗花明又一村的感觉。</p>
<p>3月10左右开始投简历，都忘记投了多少家公司了，每天都会去看一下简历状态，等待面试真的是很难受的一个过程。一开始面试的是蘑菇街，第一轮面试就挂掉了，然后小米、盛趣游戏、字节跳动、腾讯、CVTE等相继挂掉，虽然每一轮面试都入真准备，但是小厂需要可以直接干活的，大厂需要学习能力各方面都很优秀的，那我真的就没有去处了。</p>
<p>我一直感觉我是一个很幸运的人，特别是在一些人生的关键节点，都会遇到贵人相助，这次也不例外。美团点评也算大厂了，在美团点评面试之前就有一位美团点评iOS工程师打电话给我，希望我转iOS，让我好好准备笔试，这给我很好的心理暗示，然后面试的时候是一位女生面试官，人很友好，问的问题很简单，问题答不对也会引导，40分钟就结束面试了，当天就收到了第二次面试和第三次面试的邀请，这又给我了很好的心理暗示，难道默认第二轮面试通过吗？我想得太美了，第二轮是一个leader，一个多小时的面试都是基础知识轰炸，虽然很大都没有答出来，但是他还是给我过了。第三轮面试相对就比较轻松了，面试官人很好，天南地北的都聊。第二天就收到了offer call，下周一就收到了offer通知，曾为此不遗余力的复习，也曾辗转反侧的煎熬等待，终于所得届时所想，心中喜悦之情，难以言表。</p>
<p>在最近几次面试中，反复被问到了了对职业生涯有什么规划，没有想过的问题，自然回答得一团糟，但这个问题不可以回避，也无法回避，真的需要规划自己得职业生涯了，那种庸庸碌碌的校园生活所剩无几了。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/12/28/hello2020/">想要问问你，生活可如意</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-28</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/">生活随笔</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E6%80%9D%E8%80%83/">思考</a></span><div class="content"><p>在过3天就是2020年了，又一个十年的伊始。</p>
<p>回想过去十年应该是很惬意的十年，小学到初中在到高中，还有不紧不慢的大一大二两年，都过得潇洒恣意，也取得些许成就，至少无愧于自己也无愧于亲友。</p>
<p>现在的我说话已经时常用成年人打头了，成年人不能畏畏缩缩没有担当、成年人不能理所当然的继续成为家里的负担、成年人不能一事无成。</p>
<p>越是经常这样想就越是觉得失落。今年一心想着修学分，选课选得多了一些，再加上自己的资质是在过于平庸，一个学期下来整天围着作业打转，上半学期还好，还能勉强跟上，下半学期尤其是接近期末这段时间，只能是糊弄作业了，为此时常觉得难受。这种感觉在和同学们的对比总尤为强烈，自己进步得实在是太慢了，再仔细想想，自己有进步吗？</p>
<p>暂时先麻木吧，心为形役，挨过这个学期再说。</p>
<p>今年的下半年开始，考研和实习应该是思考得最为频繁得两件事。考研有风险，而且对经济独立有一种向往，所以时常在想着怎么开始第一份实习；感觉自己基础还不够扎实，尚不能胜任技术含量高得工作，而且担心本科学历会成为职业生涯的瓶颈。就是一个选择题，想了一个学期也没想明白，后来就决定先实习吧，一些主意光想就如同空中楼阁，不切实际，不如职场走一圈，去体会一下本科就业是否适合自己，就这样，路是走出来的，不是想出来的，适合什么亲自体验一番就知道了。</p>
<p>苒苒时光，当然不乏感动与快乐。</p>
<p>前两天哥哥在家人群里告知今年可能赶不上年夜饭了，让我们不要等他吃饭了，我先是厌恶它们公司放假晚而后只是无可奈何，爸爸看到消息以后说了一句“不怕伐个车去高铁站接你”，而后又说“我去高铁站联系车等你”，心里是感动的感觉，父母在的地方都是家，什么都不用怕。</p>
<p>每个人都开始忙碌各自的事，疏远的人越来越多，能够时常问候的人越来越少。和王金梅相识快十年了，感情依旧，幸甚。</p>
<p>今年课外文学阅读21本，还好阅读这个习惯没有被荒废掉。《霍乱时期的爱情》这本书使我最为震撼，贯穿一生的爱情，读来让人唏嘘。</p>
<p>一直想学口琴的，买了一把很贵的口琴却束之高阁，三分钟热度要不得。</p>
<p>今年有幸出境德国游学一次，有什么收获也说不上来，对自己的影响却是有的，时常想起自己说过好好学习，积极生活，山河俊秀，不可辜负。这个世界那么美，那么多原子聚合成一个现在的我在这宇宙千万年里就那么一次，真应该珍惜短短剑，去走遍山川湖海。</p>
<p>对下一个十年没什么规划，继续努力吧。</p>
<p>2020，对我好一点。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/11/16/%E7%9C%9F%E7%88%B1%E4%B9%8B%E4%B8%8A%EF%BC%8C%E5%8B%BF%E9%97%AE%E6%97%B6%E5%85%89/">真爱之上，勿问时光</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-11-16</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%94/">阅读随笔</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E6%80%9D%E8%80%83/">思考</a></span><div class="content"><p>船长看了看费尔明娜·达萨，在她睫毛上看到初霜的闪光。然后，他又看了看弗洛伦蒂诺·阿里萨，看到的是他那不可战胜的决心和勇敢无畏的爱。这份迟来的顿悟吓了他一跳，原来是生命，而非死亡，才是没有止境的。</p>
<p>“见鬼，那您认为我们这样来来回回的究竟走到什么时候呢？”他问。</p>
<p>在五十三年七个月零十天以来的日日夜夜，弗洛伦蒂诺·阿里萨一直都准备好了答案。</p>
<p>“一生一世。”他说。</p>
<p>断断续续读完《霍乱时期的爱情》已经快花了两个月的时间，看着书中弗洛伦蒂诺·阿里萨和费尔明娜·达萨从青年时期的青涩爱情中走失彼此，错过一生，再到生命的最后放下世俗成见，勇敢的走到一起，既唏嘘爱情的脆弱，也震撼于爱情的坚强。</p>
<p>年轻时的弗洛伦蒂诺·阿里萨曾独自一人坐在花园中的一条不易被发现的长椅上，在杏树的树荫下假装读一本诗集，直到看到那位可望不可及的姑娘走过。一念既起，执念终生。</p>
<p>弗洛伦蒂诺·阿里萨和费尔明娜·达萨也曾在情窦初开之时互相写信，通过文字悄无声息的传递着对彼此的思念和情意。</p>
<p>费尔明娜·达萨的父亲希望她的女儿通过一桩美满的婚事获得新生，两个年轻人脆弱且卑微，没有站在一起对抗世俗的风雨，一个短暂的远走他乡，一个被迫与父亲远游历练，在安排之下嫁给了声名显赫的医生。</p>
<p>弗洛伦蒂诺·阿里萨没有放下执念，跳出时光洪流，开始一生的等待。虽然费尔明娜·达萨已为人妻，在在柴米油盐中经历着所有人都会经历的酸甜苦辣、争吵和欢笑，但是弗洛伦蒂诺·阿里萨安心的修缮好房子就，并且决心一生独身，他自然的等待，等待费尔明娜·达萨的丈夫死去，再让他有机会得到她的爱。他的心是觉得忠诚的，虽然身体曾经无数次出轨。</p>
<p>长达五十一年等待后费尔明娜·达萨的丈夫意外死亡，弗洛伦蒂诺·阿里萨第一时间开始了对她的最求，回忆瞬间涌来，仿佛五十余年的时光不曾流逝。这一次，费尔明娜·达萨已经不再惧怕世俗压力，她说：“一个世纪以前，人们毁掉了我和这个可怜男人的生活，因为我们太年轻；现在又想在我们身上故技重施，因为我们太老了，让他们见鬼去吧，如果说我们这些寡妇有什么优势的话，那就是再也没有人可以对我们发号施令了。”</p>
<p>两个人在船上度过了最快乐的时光，也许是最后的时光。</p>
<p>读这本书的过程中多次想起一句歌词：假如我年少有为不自卑，懂得什么是珍贵；假如我年少有为知进退，才不会让你替我受罪。经常会看到很多人遗憾在最想照顾一个人的时候没有足够的勇气和能力，等到失去之后，虽然能力已经匹配，也有了抵抗流言的勇气，却也只能是一个人独自挣扎了，爱的人早就走散了，不甘心却也再也求不得。</p>
<p>这样的事情几千年了一直都有，别人的故事一直在听，自己却怎么也学不会的，真正要懂的道理，只有自己亲身经历并为之付出代价才能学会的，代价越惨重，领悟越深刻，这个时候道理记住与否多半不重要了，失去了就真的失去了，有些人有些事一辈子只能有一次。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/08/27/%E5%8D%81%E6%97%A5%E6%B8%B8%E5%AD%A6%EF%BC%8C%E7%A9%BF%E8%B6%8A%E5%BE%B7%E5%9B%BD/">十日游学，穿越德国</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-27</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E4%BA%BA%E7%94%9F%E5%B1%A5%E5%8E%86/">人生履历</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a></span><div class="content"><p>day  1<br>经过十六个小时的飞行，今天早上十点到达德国汉堡。从起飞时俯瞰广州夜景的兴奋，到震惊于伊斯坦布尔的繁华，到身临其境的感受汉堡怡然自得的城市生活。汉堡给我的第一印象就是这里真是一座适合养老的城市，气候适宜，环境优美，生活节奏不慌不忙。街头两侧的房子都是精心设计的艺术品，红褐色的砖，凸起的房梁，朴素自然的装修，看起来美极了，真想为每一栋房子拍一张照片。<br>可口的中国餐，参观汉堡大学，夜晚结伴逛超市，真是美好的一天，我太困了，先睡觉了。</p>
<p>day 2<br>吃完早餐以后向汉诺威市进发，约一个小时来到了今天的第一站SLC，这是一家仓储公司，虽然先后进行了公司介绍，实地观摩，视频讲解等环节，我对这个公司在使用IT技术使得它不同于传统仓库的地方还是没有什么概念，当然不是吴导翻译的问题，只是我觉得并没有什么特别之处。<br>在观摩结束以后两点总结我觉得很有意义，第一，企业发展不可能是一本企划书就可以一蹴而就的，需要在不断的发展中不断试错，不断改进，第二，一个人对一件事不感兴趣也可以做得好，但是如果想把一件事做到极致，却缺兴趣不可，这让我我很焦虑，计算机科学发展得如火如荼，而我真的对它感兴趣吗？外加一点思考，企业发展不是单独依靠技术人才或者财务人才或者公关人才就能发展得好的，一个企业就是一个系统，决策者在领导企业前进的时候必须综合考量，不能违背经济学总资本追逐利这一基本原则。<br>中午了一些汉堡，薯条，可乐何水果沙拉，和妈妈打电话时国内已经八点了，真想带爸爸妈妈经历一下他们觉得很新奇的事。<br>三个小时来到市政厅，德国的高速公路真慢。给王金梅寄出了一张明信片，我好希望它能收到啊 。晚餐是一顿中餐，和张伟聊得挺好。入住酒店以后逛了商场，基本上都在八点钟关门了，德国人真悠闲。</p>
<p>day3</p>
<p>今天早上都在前往柏林的路上，下午达到柏林，在WISTA听取了他们关于高新技术园区产业孵化的介绍，认为大学，研究生，工厂三个要素是产业发展的必要条件，由于有些困倦，没有记住其他要点。<br>在乘车去吃饭的路上，遇见路边有一些其他国家的难民在公路边上给人家洗车，虽然一些司机拒绝给小费或者在他们的坚持索要下才勉强给了很少的小费，但是他们的脸上仍然洋溢着乐观自信的笑容，这让我很感动。生活多舛，我们唯有乐观可以在苦难面前从容不惊。</p>
<p>day4<br>今天周六，是休闲的一天。先后游览了胜利柱、苏联攻占柏林纪念园、帝国大厦、五大部、总理府、勃兰登堡门、屠杀犹太人纪念园、柏林墙、洪堡大学、圣母大教堂、博物馆、马克思恩格斯纪念园。<br>在游览柏林墙的时候看到几个黑人在很惬意的享受周末，本来想拍他们，但他们不知为何非常紧张，就此作罢。<br>午餐的时候和学院副书记闲聊追求时尚，他的观点认为受过教育的人应该形成自己的品味，不能被潮流引领，否则会沦为欲望的奴隶，我很认同。<br>八点回到酒店，倒下就睡着了，凌晨十二点才醒过来。</p>
<p>day4<br>今天周六，是休闲的一天。先后游览了胜利柱、苏联攻占柏林纪念园、帝国大厦、五大部、总理府、勃兰登堡门、屠杀犹太人纪念园、柏林墙、洪堡大学、圣母大教堂、博物馆、马克思恩格斯纪念园。<br>在游览柏林墙的时候看到几个黑人在很惬意的享受周末，本来想拍他们，但他们不知为何非常紧张，就此作罢。<br>午餐的时候和学院副书记闲聊追求时尚，他的观点认为受过教育的人应该形成自己的品味，不能被潮流引领，否则会沦为欲望的奴隶，我很认同。<br>八点回到酒店，倒下就睡着了，凌晨十二点才醒过来。</p>
<p>day 5<br>今天是星期天，仍然是德国人休息的一天，。早餐以后乘车前往莱比锡，中午到达，莱比锡在历史上属于东德，东德是社会主义阵营的一部分，也可以看出来相比于资本主义阵营西德的贫穷落后。午餐完毕前往德国民族大会战纪念碑，四周景色尽收眼底。继续参观德国公墓和中央火车站，大概了解了德国的丧葬文化，对德国人热衷植树还是很佩服的，这历史久远的火车站不像火车站，里面各种商铺尽管是星期天也正在营业。逗留太长时间，没有时间参观莱比锡大学和市政厅了。</p>
<p>day 6<br>今天可以说一天都是在车上度过的。八点出发前往美因茨，高速公路两旁的景物已经渐渐由平原变成森林，阳哥撒在松树上的暖色让人很享受。下午三点到达美因茨大学，听了教授关于德国数字化的讲座，有幸得到一个提问机会，我问教授为什么移动支付如此方便但是德国却不使用，他的回答说银行资本家拒绝使用，这也许就是资本主义的弊端，阻碍生产力进步。讲座结束继续乘车前往美因河畔法兰克福。</p>
<p>day 7<br>今天从法兰克福前往斯图加特参观凯驰生产线，高速公路两旁开始出现出现山峦，平缓的山坡上星罗棋布的种了一些苹果树，大巴行驶几分钟便会出现静谧的欧洲小镇。早上十点抵达。讲座和生产线观摩，给我印象最深的就是德国中小型企业对独特品牌的执着追求，对质量的严格把关，他们始终坚持做一种产品，并把这个产品做成全行业第一。<br>中午开始下起蒙蒙细雨，来到一个奢侈品大卖场，只不过囊中羞涩，什么都没买。</p>
<p>day 8<br>今天一早便开车去海德堡，沿着内卡河行驶一会儿下车，跟着吴导走在欧式风格的小镇上，遥望海德堡城堡，探访海德堡大学，真是一件惬意的事情。独自爬山来到哲学家小路，据说这是康德等哲学家曾经走过的小路，这条小路上人很多，但是大家都很惬意的在散步，不慌不忙。遥望远处，红色砖瓦的欧式风格小屋连成一片，绵延到远方。下山的时候一个中国女孩请我给她拍照，我很开心，因为听到中文真的不容易。<br>午餐结束以后乘车返回斯图加特参观梅赛德斯奔驰博物馆，偶遇一个女孩，不知姓名不知国籍，就是觉得她好美，全程无心观车，要么尾随其后，要么站在她会经过的地方带她经过，可以想象喜欢一个人会有多么卑微。</p>
<p>day 9<br>早上从斯图加特前往辛德芬根参观梅赛德斯奔驰生产线，第一条生产线全是机械手在流水线上加工汽车，这让人很震撼，机械化程度如此之高的工厂，德国不愧是一个工业强国，中国相比之下还差得很远。第二条生产线是定制化生产线，个人都在流水线上各司其职，但是生产效率也同样很高，一天可以完成170台左右。<br>乘车前往慕尼黑的路上，猪排和炸土豆作为简单的午餐，下午四点到达慕尼黑，两个小时的购物时间，强哥，家源和我还是一样都没有买，我手机没电独自去找洗手间，资本主义太可怕了，地铁站里的洗手间都要收费，无奈没带钱，只能忍着了。闲逛之余，看到街头忘我的弹钢琴的男子，夕阳撒在教堂的余晖，一切都那么赏心悦目，很开心一个中国同胞和我打招呼。<br>今天晚上的晚餐比较特别，到德国皇家啤酒屋就餐，9欧元的半杯啤酒喝得我心痛，这里挤满了人，大家啤酒和猪脚吃得很开心，加上愉快的音乐，真是一个美好的晚上。</p>
<p>day 10<br>今天是在德国的最后一天，原定计划参访慕尼黑工业大学，与留学生联谊的活动莫名其妙就没有了，早上起来直接前往市中心自由活动，我选择临走之前给家人买一点礼物。<br>逛了许久给弟弟买了一块手表，给爸爸买了一个钱包，由于时间不够，也是不了解妈妈和哥哥的喜好，没有给他们买，很遗憾。两件礼物折算人民币挺贵的，但是难得来一次，就狠心买了，以后努力挣钱吧。<br>六点半起飞，九点抵达土耳其的伊斯坦布尔，本来凌晨一点的飞机居然延误到五点，太难了。</p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://images.zhulk3.xyz/blog/sky.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2023 By hohnor</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>